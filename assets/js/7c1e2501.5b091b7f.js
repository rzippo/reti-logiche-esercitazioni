"use strict";(self.webpackChunkreti_logiche_esercitazioni=self.webpackChunkreti_logiche_esercitazioni||[]).push([[8337],{12086:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"esercitazioni/Assembler/Esercitazioni/Esercitazione 1","title":"Esercitazione 1","description":"","source":"@site/versioned_docs/version-2025-26/esercitazioni/Assembler/Esercitazioni/1. Esercitazione 1.mdx","sourceDirName":"esercitazioni/Assembler/Esercitazioni","slug":"/esercitazioni/Assembler/Esercitazioni/Esercitazione 1","permalink":"/reti-logiche-esercitazioni/esercitazioni/Assembler/Esercitazioni/Esercitazione 1","draft":false,"unlisted":false,"tags":[],"version":"2025-26","sidebarPosition":1,"frontMatter":{"description":""},"sidebar":"esercitazioniSidebar","previous":{"title":"Esercitazioni","permalink":"/reti-logiche-esercitazioni/category/esercitazioni"},"next":{"title":"Documentazione","permalink":"/reti-logiche-esercitazioni/category/documentazione"}}');var o=n(74848),a=n(28453);const s={description:""},c="Esercitazione 1",l={},d=[{value:"Premesse per programmi nell&#39;ambiente del corso",id:"premesse-per-programmi-nellambiente-del-corso",level:2},{value:"Esercizio 1.1",id:"esercizio-11",level:2},{value:"Uso del debugger",id:"uso-del-debugger",level:2},{value:"Domande a risposta multipla",id:"domande-a-risposta-multipla",level:2},{value:"15/07/2025, domanda 9",id:"15072025-domanda-9",level:3},{value:"24/06/2025, domanda 9",id:"24062025-domanda-9",level:3},{value:"09/09/2025, domanda 3",id:"09092025-domanda-3",level:3},{value:"Esercizi per casa",id:"esercizi-per-casa",level:2},{value:"Esercizio 1.2: istruzioni stringa",id:"esercizio-12-istruzioni-stringa",level:2},{value:"Esercizi 1.3 e 1.4",id:"esercizi-13-e-14",level:3},{value:"Esercizio 1.5",id:"esercizio-15",level:3},{value:"Esercizio 1.6",id:"esercizio-16",level:3}];function t(e){const i={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mdxAdmonitionTitle:"mdxAdmonitionTitle",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"esercitazione-1",children:"Esercitazione 1"})}),"\n",(0,o.jsxs)(i.p,{children:["La caratteristica principale del programmare in assembler \xe8 che le operazioni a disposizione sono solo quelle messe a disposizione dal processore.\r\nInfatti, l'assemblatore fa molto poco: dopo aver sostituito le varie label con indirizzi, traduce ciascuna istruzione, nell'ordine in cui sono presenti, nel diretto corrispettivo binario (il cosiddetto linguaggio macchina).\r\nQuesto binario \xe8 poi eseguito direttamente dal processore.\r\nDato un algoritmo per risolvere un problema, i passi base di questo algoritmo ",(0,o.jsx)(i.em,{children:"devono"})," essere istruzioni comprese dal processore, e siamo quindi limitati dall'hardware e le sue caratteristiche."]}),"\n",(0,o.jsxs)(i.p,{children:["Per esempio, dato che il processore non supporta ",(0,o.jsx)(i.code,{children:"mov"})," da un indirizzo di memoria a un altro indirizzo di memoria, non possiamo fare questa operazione con una sola istruzione: dobbiamo invece scomporre in ",(0,o.jsx)(i.code,{children:"mov src, %eax"})," ",(0,o.jsx)(i.code,{children:"mov %eax, dest"}),", assicurandoci nel frattempo di non aver perso alcun dato importante prima contenuto in ",(0,o.jsx)(i.code,{children:"%eax"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"Per svolgere gli esercizi, bisogna quindi imparare a scomporre strutture di programmazione gi\xe0 note (come if-then-else, cicli, accesso a vettore) nelle operazioni elementari messe ad disposizione dal processore, usando il limitato numero di registri a disposizione al posto di variabili, e tenendo presente quali operazioni da fare con quali dati, senza un sistema di tipizzazione ad aiutarci."}),"\n",(0,o.jsx)(i.h2,{id:"premesse-per-programmi-nellambiente-del-corso",children:"Premesse per programmi nell'ambiente del corso"}),"\n",(0,o.jsxs)(i.p,{children:["Unica eccezione alla logica di cui sopra sono i sottoprogrammi di ingresso/uscita, forniti tramite ",(0,o.jsx)(i.code,{children:"utility.s"}),":\r\nquesti interagiscono con il terminale tramite il ",(0,o.jsx)(i.em,{children:"kernel"})," usando il meccanismo delle ",(0,o.jsx)(i.em,{children:"interruzioni"}),", concetti che avrete il tempo di esplorare in corsi successivi.\r\nQui ci limiteremo a seguirne le specifiche, documentate ",(0,o.jsx)(i.a,{href:"/reti-logiche-esercitazioni/esercitazioni/Assembler/Documentazione/Sottoprogrammi%20utility",children:"qui"}),", per leggere o stampare a video numeri, caratteri, o stringhe.\r\nPer esempio, parte di queste specifiche \xe8 l'uso del carattere di ritorno carrello ",(0,o.jsx)(i.code,{children:"\\r"})," come terminatore di stringa.\r\nPer usarli, per\xf2, va istruito l'assemblatore di aggiungere questi sottoprogrammi al nostro codice, con"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:'.include "./files/utility.s"\n'})}),"\n",(0,o.jsxs)(i.p,{children:["Un altro aspetto importante \xe8 dove comincia e finisce il nostro programma:\r\n",(0,o.jsx)(i.em,{children:"nell'ambiente del corso"}),", il punto di ingresso \xe8 la label ",(0,o.jsx)(i.code,{children:"_main"})," e quello di uscita \xe8 la corrispondente istruzione ",(0,o.jsx)(i.code,{children:"ret"}),".\r\nPer motivi di debugging, che saranno chiari pi\xf9 avanti, si tende a cominciare il programma con una istruzione ",(0,o.jsx)(i.code,{children:"nop"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Inoltre, la distinzione tra zona ",(0,o.jsx)(i.code,{children:".data"})," e ",(0,o.jsx)(i.code,{children:".text"})," \xe8 importante.\r\nDato che durante l'esecuzione sono ",(0,o.jsx)(i.em,{children:"entrambi"})," caricati in memoria, per motivi di sicurezza il kernel Linux ci impedir\xe0 di ",(0,o.jsx)(i.em,{children:"eseguire"})," indirizzi in ",(0,o.jsx)(i.code,{children:".data"})," o di ",(0,o.jsx)(i.em,{children:"scrivere"})," in indirizzi in ",(0,o.jsx)(i.code,{children:".text"}),".\r\nDimenticarsi di dichiararli porta a eccezioni durante l'esecuzione."]}),"\n",(0,o.jsx)(i.p,{children:"Infine, l'assemblatore non vede di buon occhio la mancanza di una riga vuota alla fine del file.\r\nPer evitare messaggi di warning inutili, meglio aggiungerla."}),"\n",(0,o.jsxs)(i.p,{children:["Detto ci\xf2, possiamo quindi comprendere il ",(0,o.jsx)(i.a,{href:"pathname:///2025-26/code/assembler/test-ambiente.s",children:"programma di test"}),', che non fa che stampare "Ok." a terminale e poi termina:']}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n.data\r\nmessaggio: .ascii "Ok.\\r"\r\n\r\n.text\r\n_main:  \r\n    nop\r\n    lea messaggio, %ebx\r\n    call outline\r\n    ret\r\n\n'})}),"\n",(0,o.jsxs)(i.admonition,{title:"Queste premesse si applicano solo a questo corso",type:"note",children:[(0,o.jsxs)(i.p,{children:["Le istruzioni di questa sezione sono relative all'ambiente del corso.\r\nLa direttiva ",(0,o.jsx)(i.code,{children:'.include "./files/utility.s"'})," ricopia il codice del file ",(0,o.jsx)(i.code,{children:"utility.s"}),", fornito nell'ambiente del corso.\r\nLe specifiche dei sottoprogrammi (uso dei registri, ",(0,o.jsx)(i.code,{children:"\\r"})," come carattere di terminazione, etc.) sono conseguenza di come \xe8 scritto questo codice, che ha a che fare con scelte fatte da noi, per esempio per mantenere la retrocompatibilit\xe0 con il vecchio ambiente DOS utilizzato precedentemente sempre in questo corso.\r\nL'uso di ",(0,o.jsx)(i.code,{children:"_main"})," e ",(0,o.jsx)(i.code,{children:"ret"})," (peraltro, senza alcun valore di ritorno), cos\xec come il comportamento del terminale, sono anche questi relativi all'ambiente usato."]}),(0,o.jsx)(i.p,{children:"Non sono assolutamente concetti validi in generale, per altri assembler e altri ambienti.\r\nTenete questo ben presente nel caso vi avvicinaste allo sviluppo di assembler in altri contesti."})]}),"\n",(0,o.jsx)(i.h2,{id:"esercizio-11",children:"Esercizio 1.1"}),"\n",(0,o.jsx)(i.p,{children:"Partiamo da un esercizio con le seguenti specifiche"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"1. Leggere messaggio da terminale.\r\n2. Convertire le lettere minuscole in maiuscolo.\r\n3. Stampare messaggio modificato.\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Per i passi 1 e 3 possiamo usare i sottoprogrammi di utility ",(0,o.jsx)(i.code,{children:"inline"})," e ",(0,o.jsx)(i.code,{children:"outline"})," (",(0,o.jsx)(i.a,{href:"/reti-logiche-esercitazioni/esercitazioni/Assembler/Documentazione/Sottoprogrammi%20utility",children:"documentazione"}),").\r\nCominciamo riservando in memoria, nella sezione data, spazio per le due stringhe."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:".data\r\n\r\nmsg_in: .fill 80, 1, 0\r\nmsg_out: .fill 80, 1, 0\n"})}),"\n",(0,o.jsx)(i.p,{children:"Per la lettura useremo"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"mov $80, %cx\r\nlea msg_in, %ebx\r\ncall inline\n"})}),"\n",(0,o.jsx)(i.p,{children:"Per la scrittura invece useremo"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"lea msg_out, %ebx\r\ncall outline\n"})}),"\n",(0,o.jsx)(i.p,{children:"Quel che manca ora \xe8 il punto 2.\r\nDobbiamo (capire come) fare diverse cose:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["ricopiare ",(0,o.jsx)(i.code,{children:"msg_in"})," in ",(0,o.jsx)(i.code,{children:"msg_out"})," carattere per carattere"]}),"\n",(0,o.jsxs)(i.li,{children:["controllare tale carattere, per capire se \xe8 una lettera minuscola","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"se s\xec, cambiare tale carattere nella corrispondente maiuscola"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Cominciamo dal capire il primo punto, cio\xe8 come ricopiare il messaggio, ignorando per ora la gestione dei caratteri minuscoli."}),"\n",(0,o.jsxs)(i.p,{children:["Come scorrere i due vettori? Abbiamo due opzioni: usare un indice per accesso indicizzato, o due puntatori da incrementare.\r\nAnche sulla condizione di terminazione abbiamo due opzioni: fermarsi dopo aver processato il carattere di ritorno carrello ",(0,o.jsx)(i.code,{children:"\\r"}),", o dopo aver processato 80 caratteri."]}),"\n",(0,o.jsx)(i.p,{children:"Per questo esercizio, scegliamo la prima opzione per entrambe le scelte.\r\nSe usassimo C, scriveremmo qualcosa simile a questo:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-c",children:"char[] msg_in, msg_out;\r\n...\r\nint i = 0;\r\nchar c;\r\ndo {\r\n    c = msg_in[i];\r\n    // si pu\xf2 trasformare c qui\r\n    msg_out[i] = c;\r\n    i++;\r\n} while (c != '\\r')\n"})}),"\n",(0,o.jsx)(i.p,{children:"In assembler, questo si pu\xf2 scrivere cos\xec:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    mov $0, %ecx\r\nloop:   \r\n    movb (%esi, %ecx), %al\r\n    # si pu\xf2 trasformare %al qui\r\n    movb %al, (%edi, %ecx)\r\n    inc %ecx\r\n    cmp $0x0d, %al # $0x0d \xe8 equivalente a $'\\r'\r\n    jne loop\n"})}),"\n",(0,o.jsx)(i.p,{children:"Ci sono diversi aspetti da sottolineare.\r\nIl primo \xe8 che nell'accesso con indice, a differenza del C, abbiamo completo controllo sia di come \xe8 calcolato l'indirizzo di accesso, sia sulla dimensione della lettura in memoria."}),"\n",(0,o.jsxs)(i.p,{children:["Prendiamo il caso di ",(0,o.jsx)(i.code,{children:"movb (%esi, %ecx), %al"}),".\r\nRicordiamo che il formato dell'indirizzazione con indice \xe8 ",(0,o.jsx)(i.code,{children:"offset(%base, %indice, scala)"}),", dove l'indirizzo \xe8 calcolato come ",(0,o.jsx)(i.code,{children:"offset + %base + (%indice * scala)"}),".\r\nDunque ",(0,o.jsx)(i.code,{children:"(%esi, %ecx)"})," \xe8, implicitamente, ",(0,o.jsx)(i.code,{children:"0(%esi, %ecx, 1)"}),", dove l'1 indica il fatto che ci spostiamo di un byte alla volta.\r\nDato l'indirizzo, per\xf2, in abbiamo controllo di quanti byte leggere, questa volta tramite il suffisso ",(0,o.jsx)(i.code,{children:"b"})," o, implicitamente, tramite la dimensione del registro di destinazione ",(0,o.jsx)(i.code,{children:"%al"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["In C, tutti questi aspetti sono gestiti automaticamente come conseguenza dell'uso del tipo ",(0,o.jsx)(i.code,{children:"char"}),", che \xe8 appunto di 1 byte.\r\nIn assembler, ",(0,o.jsx)("u",{children:"dobbiamo starci attenti noi"}),".\r\nInfatti, il processore esegue le istruzioni senza alcun controllo (n\xe9 cognizione) su che tipo di dato stiamo cercando di accedere e dove."]}),"\n",(0,o.jsxs)(i.p,{children:["Prima di passare al resto del punto 2, vale la pena provare a comporre il programma cos\xec com'\xe8, testarlo ed eseguirlo.\r\nInfatti, \xe8 sempre una buona idea trovare i bug quanto prima, e quanto pi\xf9 \xe8 semplice il codice scritto tanto pi\xf9 lo \xe8 trovare la fonte del bug.\r\nIl codice scritto finora \xe8 scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2025-26/code/assembler/1/maiusc_p1.s",children:"qui"}),", e questo \xe8 l'output che otteniamo provando ad assemblarlo ed eseguirlo."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-pwsh",children:"PS /mnt/c/reti_logiche/assembler> ./assemble.ps1 ./esercitazioni/1/maiusc_p1.s\r\nPS /mnt/c/reti_logiche/assembler> ./esercitazioni/1/maiusc_p1           \r\nquesto E' UN test\r\nquesto E' UN test\r\nPS /mnt/c/reti_logiche/assembler> \n"})}),"\n",(0,o.jsxs)(i.p,{children:["Passiamo adesso ai punti ignorati prima, ossia controllare che il carattere letto sia una minuscola, e nel caso cambiarla in maiuscola.\r\nPer controllare che un carattere sia una lettera minuscola, ci basta ricordare che i caratteri ASCII hanno una codifica binaria ordinata: ",(0,o.jsx)(i.code,{children:"char c"})," \xe8 minuscola se ",(0,o.jsx)(i.code,{children:"c >= 'a' && c <= 'z'"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Per cambiare invece una minuscola e maiuscola, notiamo sempre dalla tabella ASCII che, per lo stesso motivo, la distanza tra ",(0,o.jsx)(i.code,{children:"'a'"})," e ",(0,o.jsx)(i.code,{children:"'A'"})," \xe8 la stessa di qualunque altra coppia di maiuscola-minuscola.\r\nTale distanza \xe8 32: ci basta infatti sottrarre 32 a una minuscola per ottenere la corrispondente maiuscola, e aggiungere 32 per fare il contrario.\r\nGuardando alla rappresentazione in base 2, notiamo che l'operazione \xe8 (non per caso) ancora pi\xf9 semplice: essendo ",(0,o.jsxs)(i.span,{className:"katex",children:[(0,o.jsx)(i.span,{className:"katex-mathml",children:(0,o.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(i.semantics,{children:[(0,o.jsxs)(i.mrow,{children:[(0,o.jsx)(i.mn,{children:"32"}),(0,o.jsx)(i.mo,{children:"="}),(0,o.jsxs)(i.msup,{children:[(0,o.jsx)(i.mn,{children:"2"}),(0,o.jsx)(i.mn,{children:"5"})]})]}),(0,o.jsx)(i.annotation,{encoding:"application/x-tex",children:"32 = 2^5"})]})})}),(0,o.jsxs)(i.span,{className:"katex-html","aria-hidden":"true",children:[(0,o.jsxs)(i.span,{className:"base",children:[(0,o.jsx)(i.span,{className:"strut",style:{height:"0.6444em"}}),(0,o.jsx)(i.span,{className:"mord",children:"32"}),(0,o.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,o.jsx)(i.span,{className:"mrel",children:"="}),(0,o.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,o.jsxs)(i.span,{className:"base",children:[(0,o.jsx)(i.span,{className:"strut",style:{height:"0.8141em"}}),(0,o.jsxs)(i.span,{className:"mord",children:[(0,o.jsx)(i.span,{className:"mord",children:"2"}),(0,o.jsx)(i.span,{className:"msupsub",children:(0,o.jsx)(i.span,{className:"vlist-t",children:(0,o.jsx)(i.span,{className:"vlist-r",children:(0,o.jsx)(i.span,{className:"vlist",style:{height:"0.8141em"},children:(0,o.jsxs)(i.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,o.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,o.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,o.jsx)(i.span,{className:"mord mtight",children:"5"})})]})})})})})]})]})]})]}),", si tratta di mettere il bit in posizione 5 a 0 o 1, usando ",(0,o.jsx)(i.code,{children:"and"}),", ",(0,o.jsx)(i.code,{children:"or"})," o ",(0,o.jsx)(i.code,{children:"xor"})," con maschere appropriate."]}),"\n",(0,o.jsx)(i.p,{children:"Detto ci\xf2, il codice C diventa:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-c",children:"char[] msg_in, msg_out;\r\n...\r\nint i = 0;\r\nchar c;\r\ndo {\r\n    c = msg_in[i];\r\n    if(c >= 'a' && c <= 'z')\r\n        c = c & 0xdf;\r\n    msg_out[i] = c;\r\n    i++;\r\n} while (c != '\\r')\n"})}),"\n",(0,o.jsxs)(i.p,{children:["La notazione esadecimale ",(0,o.jsx)(i.code,{children:"0xdf"})," corrisponde a ",(0,o.jsx)(i.code,{children:"1101 1111"}),".\r\nFare un ",(0,o.jsx)(i.code,{children:"and"})," con tale maschera lascia tutti i bit invariati tranne quello in posizione 5, che viene resettato.\r\nPer esempio"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"0x63 0110 0011  'c'\r\nAND\r\n0xdf 1101 1111\r\n=\r\n0x43 0101 0011  'C'\n"})}),"\n",(0,o.jsxs)(i.admonition,{title:"Il controllo non \xe8 opzionale",type:"tip",children:[(0,o.jsx)(i.p,{children:"Domanda: se vogliamo che tutte le lettere siano maiuscole, non basta resettare il bit 5 a prescindere, e non fare il controllo?"}),(0,o.jsxs)(i.p,{children:["Risposta: no, perch\xe9 ci sono altri caratteri ASCII con il bit 5 a 1 che non sono affatto lettere. Per esempio, il carattere spazio di codifica ",(0,o.jsx)(i.code,{children:"0x20"}),"."]})]}),"\n",(0,o.jsx)(i.p,{children:"Questo si traduce nel seguente assembler:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    mov $0, %ecx\r\nloop:   \r\n    movb (%esi, %ecx), %al\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n\r\n    and $0xdf, %al      # 1101 1111 -> l'and resetta il bit 5\r\n\r\npost_check:\r\n    movb %al, (%edi, %ecx)\r\n    inc %ecx\r\n    cmp $0x0d, %al\r\n    jne loop\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Notiamo che le due condizione nell'if vanno rimaneggiate per essere tradotte da C ad assembler, infatti saltiamo a ",(0,o.jsx)(i.code,{children:"post_check"}),", dopo l'istruzione di conversione, se le condizioni ",(0,o.jsx)(i.em,{children:"non"})," sono verificate."]}),"\n",(0,o.jsxs)(i.p,{children:["Il codice finale \xe8 quindi il seguente, scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2025-26/code/assembler/1/maiusc.s",children:"qui"})," come file sorgente."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",metastring:"showLineNumbers",children:".include \"./files/utility.s\"\r\n\r\n.data\r\nmsg_in: .fill 80, 1, 0\r\nmsg_out: .fill 80, 1, 0\r\n\r\n.text\r\n_main:  \r\n    nop\r\npunto_1:\r\n    mov $80, %cx\r\n    lea msg_in, %ebx\r\n    call inline\r\n    nop\r\npunto_2:\r\n    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    mov $0, %ecx\r\nloop:   \r\n    movb (%esi, %ecx), %al\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n    and $0xdf, %al\r\npost_check:\r\n    movb %al, (%edi, %ecx)\r\n    inc %ecx\r\n    cmp $0x0d, %al\r\n    jne loop\r\npunto_3:\r\n    lea msg_out, %ebx\r\n    call outline\r\n    nop\r\nfine:\r\n    ret\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Le label ",(0,o.jsx)(i.code,{children:"punto_1"}),", ",(0,o.jsx)(i.code,{children:"punto_2"}),", ",(0,o.jsx)(i.code,{children:"punto_3"})," e ",(0,o.jsx)(i.code,{children:"fine"})," sono, come \xe8 facile verificare, del tutto opzionali.\r\nSono per\xf2 utili ai fini del debugging, che presentiamo ora."]}),"\n",(0,o.jsxs)(i.p,{children:["Sono da notare le ",(0,o.jsx)(i.code,{children:"nop"})," aggiunte prima tra le ",(0,o.jsx)(i.code,{children:"call"})," alle righe 13 e 33 e le successive label:\r\nqueste sono un workaround per ovviare a un problema di ",(0,o.jsx)(i.code,{children:"gdb"}),", che spiegher\xf2 pi\xf9 avanti."]}),"\n",(0,o.jsx)(i.h2,{id:"uso-del-debugger",children:"Uso del debugger"}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.em,{children:"Debugging is like being the detective in a crime movie where you are also the murderer."})," ",(0,o.jsx)("br",{}),"\r\n",(0,o.jsx)(i.a,{href:"https://twitter.com/fortes/status/399339918213652480",children:"Filipe Fortes"})]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["La parola ",(0,o.jsx)(i.em,{children:"debugger"})," suggerisce da s\xe9 che sia uno strumento per rimuovere bug ma, purtroppo, questo non vuol dire che lo strumento li rimuove da solo.\r\nInfatti, quello in cui ci \xe8 utile il debugger \xe8 ",(0,o.jsx)(i.em,{children:"trovare"})," i bug, seguendo l'esecuzione del programma passo passo e controllando il suo stato per capire dov'\xe8 che il suo comportamento differisce da quanto ci aspettiamo.\r\nDa l\xec, spesso indagando a ritroso e con un po' di intuito, si pu\xf2 trovare le istruzioni incriminate e correggerle."]}),"\n",(0,o.jsxs)(i.admonition,{title:"Uno strumento per essere pi\xf9 efficienti",type:"tip",children:[(0,o.jsx)(i.p,{children:"Domanda: sembra complicato, non \xe8 pi\xf9 facile rileggere il codice?"}),(0,o.jsxs)(i.p,{children:["Risposta: s\xec, lo \xe8. Ma, in genere, quando basta rileggere \xe8 perch\xe9 si \xe8 fatto un errore di digitazione, non di ragionamento. Saper usare il debugger significa sapersi tirare fuori ",(0,o.jsx)(i.em,{children:"velocemente"})," da errori che richiederebbero rileggere ",(0,o.jsx)(i.em,{children:"a fondo"})," tutto il codice."]})]}),"\n",(0,o.jsxs)(i.p,{children:["Il debugger che usiamo \xe8 ",(0,o.jsx)(i.code,{children:"gdb"}),", che funziona da linea di comando.\r\nQuesto parte da un binario eseguibile, che verr\xe0 eseguito passo passo come da noi indicato."]}),"\n",(0,o.jsxs)(i.p,{children:["Per semplicit\xe0 d'uso, l'ambiente ha uno script ",(0,o.jsx)(i.code,{children:"debug.ps1"}),", da lanciare con"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"./debug.ps1 nome-eseguibile\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Lo script fa dei controlli, tra cui assicurarsi che si sia passato ",(0,o.jsx)(i.em,{children:"l'eseguibile"})," e non ",(0,o.jsx)(i.em,{children:"il sorgente"}),", lancia il debugger con alcuni comandi tipici gi\xe0 inseriti (imposta un breakpoint a ",(0,o.jsx)(i.code,{children:"_main"})," e lancia il programma), e ne definisce altri per comodit\xe0 d'uso (",(0,o.jsx)(i.code,{children:"rr"})," e ",(0,o.jsx)(i.code,{children:"qq"}),", per riavviare il programma o uscire senza dare conferma)."]}),"\n",(0,o.jsx)(i.p,{children:"Vediamo come usarlo, lanciando il debugger sul programma realizzato nell'esercizio precedente.\r\nDopo un sezione di presentazione del programma, abbiamo del testo del tipo"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"Breakpoint 1, _main () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:9\r\n9           nop\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["Un breakpoint \xe8 un punto del programma, in genere una linea di codice, dove si desidera che il debugger fermi l'esecuzione.\r\nAvendo impostato il primo breakpoint a ",(0,o.jsx)(i.code,{children:"_main"}),", vediamo infatti che il programma si ferma alla prima istruzione relativa, che \xe8 appunto la ",(0,o.jsx)(i.code,{children:"nop"}),".\r\nImportante: il debugger si ferma ",(0,o.jsx)(i.em,{children:"prima"})," dell'esecuzione della riga indicata."]}),"\n",(0,o.jsxs)(i.p,{children:["Vediamo poi che il debugger richiede input: infatti possiamo interagire con il debugger ",(0,o.jsx)(i.em,{children:"solo"})," quando il programma \xe8 fermo.\r\nPossiamo fare tre cose in particolare:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Osservare il contenuto di registri e indirizzi di memoria (",(0,o.jsx)(i.code,{children:"info registers"})," e ",(0,o.jsx)(i.code,{children:"x"}),"),"]}),"\n",(0,o.jsxs)(i.li,{children:["Impostare nuovi breakpoints (",(0,o.jsx)(i.code,{children:"break"}),"),"]}),"\n",(0,o.jsxs)(i.li,{children:["Continuare l'esecuzione in modo controllato (",(0,o.jsx)(i.code,{children:"step"})," e ",(0,o.jsx)(i.code,{children:"next"}),") o fino al prossimo breakpoint (",(0,o.jsx)(i.code,{children:"continue"}),")"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Vediamoli in azione. Cominciamo con il proseguire fino alla riga 13."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"Breakpoint 1, _main () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:9\r\n9           nop\r\n(gdb) step\r\npunto_1 () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:11\r\n11          mov $80, %cx\r\n(gdb) s\r\n12          lea msg_in, %ebx\r\n(gdb) s\r\n13          call inline\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["Notiamo che ",(0,o.jsx)(i.code,{children:"gdb"})," accetta sia comandi per esteso sia abbreviati, per esempio per ",(0,o.jsx)(i.code,{children:"step"})," va bene anche ",(0,o.jsx)(i.code,{children:"s"}),".\r\nCon questi 3 step, abbiamo eseguito le prime tre istruzioni ma ",(0,o.jsx)(i.em,{children:"non"})," la ",(0,o.jsx)(i.code,{children:"call"})," a riga 13.\r\nPossiamo controllare lo stato dei registri usando ",(0,o.jsx)(i.code,{children:"info registers"}),", abbreviabile con ",(0,o.jsx)(i.code,{children:"i r"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) i r\r\neax            0x66                102\r\necx            0x50                80\r\nedx            0x2d                45\r\nebx            0x56559066          1448448102\r\nesp            0xffffc06c          0xffffc06c\r\nebp            0xffffc078          0xffffc078\r\nesi            0xf7fb2000          -134537216\r\nedi            0xf7fb2000          -134537216\r\neip            0x5655676e          0x5655676e <punto_1+10>\r\neflags         0x282               [ SF IF ]\r\ncs             0x23                35\r\nss             0x2b                43\r\nds             0x2b                43\r\nes             0x2b                43\r\nfs             0x0                 0\r\ngs             0x63                99\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsxs)(i.p,{children:["Notare: \xe8 ",(0,o.jsx)(i.em,{children:"un caso"})," trovare i registri gi\xe0 inizializzati a 0, come qui mostrato."]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Questo ci da info su diversi registri, molti dei quali non ci interessano.\r\nPossiamo specificare quali registri vogliamo, anche di dimensioni minori di 32 bit."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) i r cx ebx\r\ncx             0x50                80\r\nebx            0x56559066          1448448102\r\n(gdb)\n"})}),"\n",(0,o.jsxs)(i.p,{children:["La prossima istruzione, se lasciamo il programma eseguire, \xe8 una ",(0,o.jsx)(i.code,{children:"call"}),".\r\nIn questo caso, abbiamo due scelte: proseguire ",(0,o.jsx)(i.em,{children:"nella"})," chiamata al sottoprogramma (andando quindi alle istruzioni di ",(0,o.jsx)(i.code,{children:"inline"}),", definite in ",(0,o.jsx)(i.code,{children:"utility.s"}),"), od ",(0,o.jsx)(i.em,{children:"oltre"})," la chiamata, andando quindi direttamente alla riga 14.\r\nQuesta \xe8 la differenza fra ",(0,o.jsx)(i.code,{children:"step"})," e ",(0,o.jsx)(i.code,{children:"next"}),": ",(0,o.jsx)(i.code,{children:"step"})," prosegue dentro i sottoprogrammi, mentre ",(0,o.jsx)(i.code,{children:"next"})," prosegue finch\xe9 il sottoprogramma non ritorna."]}),"\n",(0,o.jsxs)(i.p,{children:["\xc8 qui per\xf2 che \xe8 rilevante la presenza della ",(0,o.jsx)(i.code,{children:"nop"})," aggiunta a riga 14, prima di ",(0,o.jsx)(i.code,{children:"parte_2"}),".\r\n",(0,o.jsx)(i.code,{children:"next"})," infatti continua fino alla prossima istruzione della ",(0,o.jsx)(i.em,{children:"sezione corrente"})," del codice, che \xe8 in questo caso ",(0,o.jsx)(i.code,{children:"punto_1"}),".\r\nSe per\xf2 tale sezione termina subito dopo la call, e non esiste quindi una successiva istruzione nella stessa sezione, allora usando ",(0,o.jsx)(i.code,{children:"next"})," il programma continuer\xe0 fino alla terminazione.\r\nAggiungere la ",(0,o.jsx)(i.code,{children:"nop"})," ovvia al problema essendo una successiva istruzione ancora parte di ",(0,o.jsx)(i.code,{children:"punto_1"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"13          call inline\r\n(gdb) n\r\nquesto e' un test\r\n14          nop\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["Da notare che \"questo e' un test\" \xe8 proprio l'input inserito da tastiera durante l'esecuzione di ",(0,o.jsx)(i.code,{children:"inline"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Eseguire il programma un'istruzione alla volta pu\xf2 risultare molto lento.\r\nPer esempio, quando vogliamo osservare cosa succede a una particolare iterazione di un loop.\r\nPer questo ci aiutano ",(0,o.jsx)(i.code,{children:"break"})," e ",(0,o.jsx)(i.code,{children:"continue"}),".\r\nNell'esempio che segue, sono usati per raggiungere rapidamente la quarta iterazione."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) b loop\r\nBreakpoint 2 at 0x56556785: file /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s, line 20.\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) i r ecx\r\necx            0x0                 0\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) i r ecx\r\necx            0x1                 1\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) i r ecx\r\necx            0x3                 3\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["L'ultima operazione base da vedere \xe8 osservare valori in memoria.\r\nIl comando ",(0,o.jsx)(i.code,{children:"x"})," sta per ",(0,o.jsx)(i.em,{children:"examine memory"})," ma, a differenza degli altri comandi, esiste solo in forma abbreviata.\r\nIl comando ha 4 argomenti:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"N"}),', il numero di "celle" consecutive della memoria da leggere;']}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"F"}),', il formato con cui interpretare il contenuto di tali "celle", per esempio ',(0,o.jsx)(i.code,{children:"d"})," per decimale e ",(0,o.jsx)(i.code,{children:"c"})," per ASCII;"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"U"}),', la dimensione di ciascuna "cella": ',(0,o.jsx)(i.code,{children:"b"})," per 1 byte, ",(0,o.jsx)(i.code,{children:"h"})," per 2 byte, ",(0,o.jsx)(i.code,{children:"w"})," per 4 byte;"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"addr"}),", l'indirizzo in memoria da cui cominciare la lettura."]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Il formato del comando \xe8 ",(0,o.jsx)(i.code,{children:"x/NFU addr"}),".\r\nGli argomenti ",(0,o.jsx)(i.code,{children:"N"}),", ",(0,o.jsx)(i.code,{children:"F"})," e ",(0,o.jsx)(i.code,{children:"U"})," sono, di default, ",(0,o.jsx)(i.em,{children:"gli ultimi utilizzati"}),". Questo \xe8 infatti un comando ",(0,o.jsx)(i.em,{children:"con memoria"}),".\r\nQuando non sono specificati, si dovr\xe0 omettere anche lo ",(0,o.jsx)(i.code,{children:"/"}),".\r\nL'argomento ",(0,o.jsx)(i.code,{children:"addr"})," si pu\xf2 passare come"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["costante esadecimale, per esempio ",(0,o.jsx)(i.code,{children:"x 0x56559066"}),";"]}),"\n",(0,o.jsxs)(i.li,{children:["label preceduta da ",(0,o.jsx)(i.code,{children:"&"}),", per esempio ",(0,o.jsx)(i.code,{children:"x &msg_in"}),";"]}),"\n",(0,o.jsxs)(i.li,{children:["registro preceduto da ",(0,o.jsx)(i.code,{children:"$"}),", per esempio ",(0,o.jsx)(i.code,{children:"x $esi"}),";"]}),"\n",(0,o.jsxs)(i.li,{children:["espressione basata su aritmetica dei puntatori, per esempio ",(0,o.jsx)(i.code,{children:"x (int*)&msg_in+$ecx"}),"."]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"L'ultima opzione \xe8 abbastanza ostica da sfruttare, vedremo come evitarla con una tecnica alternativa."}),"\n",(0,o.jsx)(i.p,{children:"Vediamo degli esempi tornando al debugging del nostro primo programma:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) x/20cb &msg_in\r\n0x56559066:     113 'q' 117 'u' 101 'e' 115 's' 116 't' 111 'o' 32 ' '  101 'e'\r\n0x5655906e:     39 '\\'' 32 ' '  117 'u' 110 'n' 32 ' '  116 't' 101 'e' 115 's'\r\n0x56559076:     116 't' 13 '\\r' 10 '\\n' 0 '\\000'\r\n(gdb) x/20cb &msg_out\r\n0x565590b6:     81 'Q'  85 'U'  69 'E'  0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'      0 '\\000'\r\n0x565590be:     0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'     0 '\\000' 0 '\\000'        0 '\\000'\r\n0x565590c6:     0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'\r\n(gdb) x/20cb $esi\r\n0x56559066:     113 'q' 117 'u' 101 'e' 115 's' 116 't' 111 'o' 32 ' '  101 'e'\r\n0x5655906e:     39 '\\'' 32 ' '  117 'u' 110 'n' 32 ' '  116 't' 101 'e' 115 's'\r\n0x56559076:     116 't' 13 '\\r' 10 '\\n' 0 '\\000'\n"})}),"\n",(0,o.jsxs)(i.p,{children:["In questo programma usiamo un'indirizzazione con indice per leggere e scrivere lettere nei vettori.\r\nInfatti, vediamo che il registro ",(0,o.jsx)(i.code,{children:"esi"})," punta sempre alla prima lettera del vettore, e abbiamo bisogno di usare anche ",(0,o.jsx)(i.code,{children:"ecx"})," per sapere qual \xe8 la lettera che il programma intende processare in questa iterazione del loop."]}),"\n",(0,o.jsxs)(i.p,{children:["Per usare la sintassi menzionata sopra, dovremmo ricordarci come tradurre ",(0,o.jsx)(i.code,{children:"(%esi, %ecx)"})," in un'espressione di aritmetica dei puntatori.\r\nUna alternativa molto agevole \xe8 invece la scomposizione dell'istruzione ",(0,o.jsx)(i.code,{children:"movb (%esi, %ecx), %al"})," in due: una ",(0,o.jsx)(i.code,{children:"lea"})," e una ",(0,o.jsx)(i.code,{children:"mov"}),".\r\nInfatti, ricordiamo che la ",(0,o.jsx)(i.code,{children:"lea"})," ci permette di calcolare un indirizzo, anche se con composto con indice, e salvarlo in un registro.\r\nPossiamo per esempio scrivere"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"    lea (%esi, %ecx), %ebx\r\n    movb (%ebx), %al\n"})}),"\n",(0,o.jsxs)(i.p,{children:["In questo modo, l'indirizzo della lettera da leggere sar\xe0 contenuto in ",(0,o.jsx)(i.code,{children:"ebx"}),", cosa che possiamo sfruttare nel debugger con il comando ",(0,o.jsx)(i.code,{children:"x/1cb $ebx"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Come ultime indicazioni sul debugger, menzioniamo il comando ",(0,o.jsx)(i.code,{children:"layout regs"}),", che mostra a ogni passo i registri e il codice da eseguire, e i comandi ",(0,o.jsx)(i.code,{children:"r"}),", per riavviare il programma e ",(0,o.jsx)(i.code,{children:"q"}),", per terminare il debugger.\r\nLe versioni ",(0,o.jsx)(i.code,{children:"qq"})," e ",(0,o.jsx)(i.code,{children:"rr"}),", ",(0,o.jsx)(i.em,{children:"definite ad hoc nell'ambiente di questo corso"}),", fanno lo stesso senza richiedere conferma."]}),"\n",(0,o.jsx)(i.h2,{id:"domande-a-risposta-multipla",children:"Domande a risposta multipla"}),"\n",(0,o.jsx)(i.p,{children:"Vedremo ora delle domande a risposta multipla, riguardanti assembler e aritmetica.\r\nPrima per\xf2 un disclaimer, che sembra purtroppo necessario."}),"\n",(0,o.jsxs)(i.admonition,{type:"danger",children:[(0,o.jsxs)(i.mdxAdmonitionTitle,{children:["Studiare ",(0,o.jsx)(i.em,{children:"per l'esame"}),", non ",(0,o.jsx)(i.em,{children:"l'esame"})]}),(0,o.jsxs)(i.p,{children:["Le domande e gli esercizi dell'esame di Reti Logiche sono pensati perch\xe9, con la dovuta conoscenza e comprensione degli argomenti del programma del corso, sia agevole arrivare alla risposta/soluzione.\r\nCio\xe8 ",(0,o.jsx)(i.code,{children:"domanda + conoscenze => risposta"}),"."]}),(0,o.jsxs)(i.p,{children:["\xc8 invece difficile e controproducente cercare di fare il contrario: non basta fissare domande e risposte per riuscirne a derivare conoscenze di alcun tipo.\r\nAnzi, le conoscenze necessarie sono quasi del tutto assenti dal testo delle domande e delle risposte, quelle le trovate nel ",(0,o.jsx)(i.em,{children:"materiale di studio"})," del corso."]}),(0,o.jsx)(i.p,{children:'Questo disclaimer \xe8 dato nella speranza di scongiurare il frequente caso di studenti che ignorano lezioni, dispense, libri di testo e ricevimenti, cercando invece di trovare autonomamente "strategie pi\xf9 dirette".\r\nRipetendo poi l\'esame pi\xf9 e pi\xf9 volte.'})]}),"\n",(0,o.jsx)(i.h3,{id:"15072025-domanda-9",children:"15/07/2025, domanda 9"}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"mov 0x00, 0xFF\n"})}),"\n",(0,o.jsx)(i.p,{children:"Nell\u2019architettura x86 l\u2019istruzione scritta sopra:"}),"\n",(0,o.jsxs)("ol",{type:"a",children:[(0,o.jsxs)("li",{children:["copia la costante ",(0,o.jsx)(i.code,{children:"0x00"})," (su 8 bit) nella cella di memoria di indirizzo ",(0,o.jsx)(i.code,{children:"0xFF"})]}),(0,o.jsxs)("li",{children:["copia il contenuto della cella di memoria di indirizzo ",(0,o.jsx)(i.code,{children:"0x00"})," dentro la cella di indirizzo ",(0,o.jsx)(i.code,{children:"0xFF"})]}),(0,o.jsxs)("li",{children:["viene accettata dall\u2019assemblatore solo se completata con un suffisso (",(0,o.jsx)(i.code,{children:"b"}),",",(0,o.jsx)(i.code,{children:"w"}),",",(0,o.jsx)(i.code,{children:"l"}),")"]}),(0,o.jsx)("li",{children:"nessuna delle precedent"})]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Per prima cosa, ricordiamo le sintassi per operandi ",(0,o.jsx)(i.em,{children:"immediati"}),": con ",(0,o.jsx)(i.code,{children:"$0x00"})," si rappresenta il ",(0,o.jsx)(i.em,{children:"byte"})," ",(0,o.jsx)(i.code,{children:"0x00"}),", mentre con solo ",(0,o.jsx)(i.code,{children:"0x00"})," si rappresenta ",(0,o.jsx)(i.em,{children:"l'indirizzo"})," ",(0,o.jsx)(i.code,{children:"0x00"}),".\r\nVerrebbe quindi da rispondere ",(0,o.jsx)(i.em,{children:"b"}),", o ",(0,o.jsx)(i.em,{children:"c"})," se ci si accorge che non c'\xe8 nulla a indicare la dimensione dello spostamento."]}),"\n",(0,o.jsxs)(i.p,{children:["Tuttavia il dubbio \xe8 inutile, perch\xe9 la ",(0,o.jsx)(i.code,{children:"mov"})," nell'architettura x86 non supporta affatto lo spostamento tra un indirizzo di memoria a un altro;\r\nserve l'istruzione stringa ",(0,o.jsx)(i.code,{children:"movs"})," per farlo (che richiede infatti di esplicitare sempre ",(0,o.jsx)(i.code,{children:"b"}),",",(0,o.jsx)(i.code,{children:"w"})," o ",(0,o.jsx)(i.code,{children:"l"}),").\r\nLa risposta giusta \xe8 quindi la ",(0,o.jsx)(i.em,{children:"d"}),"."]}),"\n",(0,o.jsx)(i.h3,{id:"24062025-domanda-9",children:"24/06/2025, domanda 9"}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"var0: .byte 0x30, 0x31\r\nvar1: .word 0x100, 0x120\r\nvar2: .long var0+3\r\n\u2026\r\nmov var2, %ebx\r\nmov (%ebx), %al\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Alla fine del segmento di codice scritto sopra, ",(0,o.jsx)(i.code,{children:"al"})," contiene"]}),"\n",(0,o.jsxs)("ol",{type:"a",children:[(0,o.jsx)("li",{children:(0,o.jsx)(i.code,{children:"0x01"})}),(0,o.jsx)("li",{children:(0,o.jsx)(i.code,{children:"0x20"})}),(0,o.jsx)("li",{children:(0,o.jsx)(i.code,{children:"var0+3"})}),(0,o.jsx)("li",{children:"Nessuna delle precedenti"})]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Questo \xe8 un genere di esercizio che pu\xf2 trarre in inganno perch\xe9 la risposta ",(0,o.jsx)(i.em,{children:"non si trova affatto"})," sempre allo stesso modo."]}),"\n",(0,o.jsxs)(i.p,{children:["Ci\xf2 che \xe8 ",(0,o.jsx)(i.em,{children:"in comune"})," sono le cose che vanno sapute fare:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"ricostruire il layout in memoria dei dati, e quindi la corrispondenza tra un indirizzo e il byte corrispondente"}),"\n",(0,o.jsx)(i.li,{children:"distinguere le varianti di operandi immediati e forme di indirizzamento"}),"\n",(0,o.jsxs)(i.li,{children:["distinguere ",(0,o.jsx)(i.code,{children:"lea"})," e ",(0,o.jsx)(i.code,{children:"mov"})]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["A fini didattici, svolger\xf2 per intero la ricostruzione del layout in memoria, ",(0,o.jsx)(i.em,{children:"poi"})," guarder\xf2 a cosa fa il programma.\r\nAll'esame, fate il contrario."]}),"\n",(0,o.jsxs)(i.p,{children:["Cominciamo dalla prima riga: all'indirizzo ",(0,o.jsx)(i.code,{children:"var0"})," c'\xe8 il byte ",(0,o.jsx)(i.code,{children:"0x30"}),", a ",(0,o.jsx)(i.code,{children:"var0+1"})," il byte ",(0,o.jsx)(i.code,{children:"0x31"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Passiamo quindi alla seconda riga: deriviamo innanzitutto che, se questi nuovi dati cominciano a ",(0,o.jsx)(i.code,{children:"var1"}),", allora dev'essere ",(0,o.jsx)(i.code,{children:"var1 = var0 + 2"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["In questa riga i dati sono ",(0,o.jsx)(i.em,{children:"word"}),", ossia valori scritti su due byte.\r\nRicordiamo che l'architettura \xe8 ",(0,o.jsx)(i.em,{children:"little-endian"}),", ossia ",(0,o.jsx)(i.strong,{children:"little end first"}),": il byte meno significativo viene scritto prima."]}),"\n",(0,o.jsxs)(i.p,{children:["Dunque, la word ",(0,o.jsx)(i.code,{children:"0x0100"})," (il primo ",(0,o.jsx)(i.code,{children:"0"})," \xe8 implicito) viene suddivisa nei due byte ",(0,o.jsx)(i.code,{children:"0x01"})," e ",(0,o.jsx)(i.code,{children:"0x00"}),", e salvati in memoria nell'ordine ",(0,o.jsx)(i.code,{children:"0x00"})," (a ",(0,o.jsx)(i.code,{children:"var0 + 2"}),") ",(0,o.jsx)(i.code,{children:"0x01"})," (a ",(0,o.jsx)(i.code,{children:"var0 + 3"}),").\r\nSeguono, per la stessa ragione, ",(0,o.jsx)(i.code,{children:"0x20"})," (a ",(0,o.jsx)(i.code,{children:"var0 + 4"}),") e ",(0,o.jsx)(i.code,{children:"0x01"})," (a ",(0,o.jsx)(i.code,{children:"var0 + 5"}),")."]}),"\n",(0,o.jsxs)(i.p,{children:["Infine, alla terza riga abbiamo ",(0,o.jsx)(i.code,{children:"var2: .long var0+3"}),": questo \xe8 il ",(0,o.jsx)(i.em,{children:"valore di un indirizzo"}),", non il ",(0,o.jsx)(i.em,{children:"contenuto di un indirizzo"}),".\r\nQuesto valore verr\xe0 calcolato ",(0,o.jsx)(i.em,{children:"poi"})," dall'assemblatore (o altri... \xe8 complicato) in base all'indirizzo a partire dal quale verr\xe0 allocata questa sezione ",(0,o.jsx)(i.code,{children:".data"}),".\r\nDunque non possiamo prevederne il valore a priori, ma possiamo prevedere che punter\xe0 al byte pi\xf9 significativo della prima word in ",(0,o.jsx)(i.code,{children:"var1"}),": ",(0,o.jsx)(i.code,{children:"0x01"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Ora abbiamo un'idea completa di questa sezione ",(0,o.jsx)(i.code,{children:".data"}),", e possiamo passare allo svolgimento del programma."]}),"\n",(0,o.jsxs)(i.p,{children:["La prima istruzione \xe8 ",(0,o.jsx)(i.code,{children:"mov var2, %ebx"}),", dove il primo operando \xe8 un ",(0,o.jsx)(i.em,{children:"indirizzo immediato"}),".\r\nQuello che fa la ",(0,o.jsx)(i.code,{children:"mov"}),", quindi, \xe8 copiare il ",(0,o.jsxs)(i.em,{children:["valore all'indirizzo ",(0,o.jsx)(i.code,{children:"var2"})]})," nel registro ",(0,o.jsx)(i.code,{children:"%ebx"}),".\r\nDato che ",(0,o.jsx)(i.code,{children:"%ebx"})," \xe8 a 32 bit, tale copia sar\xe0 a 32 bit (cio\xe8, \xe8 implicitamente una ",(0,o.jsx)(i.code,{children:"movl"}),").\r\nDunque, ",(0,o.jsx)(i.code,{children:"%ebx"})," conterr\xe0 l'indirizzo ",(0,o.jsx)(i.code,{children:"var0+3"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["La seconda istruzione \xe8 ",(0,o.jsx)(i.code,{children:"mov (%ebx), %al"}),", dove il primo operando \xe8 un ",(0,o.jsx)(i.em,{children:"indirizzamento tramite registro"}),".\r\nQuello che fa la ",(0,o.jsx)(i.code,{children:"mov"}),", quindi, \xe8 copiare il ",(0,o.jsxs)(i.em,{children:["valore all'indirizzo contenuto in ",(0,o.jsx)(i.code,{children:"%ebx"})]})," in ",(0,o.jsx)(i.code,{children:"%al"}),".\r\nDato che ",(0,o.jsx)(i.code,{children:"%al"})," \xe8 a 8 bit, questa \xe8 implicitamente una ",(0,o.jsx)(i.code,{children:"movb"}),".\r\nDunque, \xe8 ",(0,o.jsx)(i.code,{children:"0x01"})," che viene copiato in ",(0,o.jsx)(i.code,{children:"%al"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["La risposta corretta \xe8 la ",(0,o.jsx)(i.em,{children:"a"}),"."]}),"\n",(0,o.jsxs)(i.admonition,{title:"Andare dritti al punto",type:"tip",children:[(0,o.jsxs)(i.p,{children:["Per svolgere il ragionamento di sopra, e tutte le sue varianti, c'\xe8 bisogno di padroneggiare i ",(0,o.jsx)(i.em,{children:"pochi"})," concetti elencati sopra."]}),(0,o.jsxs)(i.p,{children:["In un vero contesto d'esame, \xe8 consigliato partire dal programma (",(0,o.jsx)(i.em,{children:"poche"})," istruzioni) e svolgere direttamente e solo i calcoli richiesti da tale programma.\r\nPer esempio, in questo esercizio \xe8 stato del tutto inutile discutere dei byte a ",(0,o.jsx)(i.code,{children:"var0"})," e della seconda word di ",(0,o.jsx)(i.code,{children:"var1"}),"."]})]}),"\n",(0,o.jsx)(i.admonition,{title:"Debugger come strumento di verifica",type:"info",children:(0,o.jsxs)(i.p,{children:["Il modo pi\xf9 diretto per controllare un esercizio di questo tipo \xe8 assemblarlo e vedere con il debugger il contenuto di registri e memoria.\r\nPer esempio, con il comando ",(0,o.jsx)(i.code,{children:"x/4xb &var1"})," si pu\xf2 verificare che i byte a partire da ",(0,o.jsx)(i.code,{children:"var1"})," sono proprio quelli detti sopra."]})}),"\n",(0,o.jsx)(i.h3,{id:"09092025-domanda-3",children:"09/09/2025, domanda 3"}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.code,{children:"add %al, %bl"})}),"\n",(0,o.jsxs)(i.p,{children:["Dopo l'istruzione riportata sopra, quale delle seguenti configurazioni degli operandi scrive 1 dentro ",(0,o.jsx)(i.code,{children:"OF"}),", e 1 dentro ",(0,o.jsx)(i.code,{children:"CF"}),"?"]}),"\n",(0,o.jsxs)("ol",{type:"a",children:[(0,o.jsxs)("li",{children:["al = ",(0,o.jsx)(i.code,{children:"0100_0000"}),", bl = ",(0,o.jsx)(i.code,{children:"0100_0000"})]}),(0,o.jsxs)("li",{children:["al = ",(0,o.jsx)(i.code,{children:"1000_0000"}),", bl = ",(0,o.jsx)(i.code,{children:"1000_0000"})]}),(0,o.jsxs)("li",{children:["al = ",(0,o.jsx)(i.code,{children:"1111_1111"}),", bl = ",(0,o.jsx)(i.code,{children:"0000_0001"})]}),(0,o.jsx)("li",{children:"Nessuna delle precedenti"})]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Per rispondere, ricapitoliamo come si comportano l'istruzione ",(0,o.jsx)(i.code,{children:"add"})," e i flag ",(0,o.jsx)(i.code,{children:"OF"})," e ",(0,o.jsx)(i.code,{children:"CF"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Si parte dal fatto che la somma di numeri naturali e numeri interi in complemento alla radice (CR) eseguono ",(0,o.jsx)(i.em,{children:"esattamente le stesse operazioni"}),".\r\nQuindi abbiamo una sola istruzione ",(0,o.jsx)(i.code,{children:"add"})," che va usata sia che gli operandi vadano interpretati come naturali, sia che vadano interpretati come interi."]}),"\n",(0,o.jsx)(i.p,{children:"Per il processore, per\xf2, non c'\xe8 nulla che indichi se siamo nell'uno o nell'altro caso.\r\nDunque, i flag relativi vengono popolati in ogni caso, e sta a noi controllare i flag giusti in base all'operazione svolta."}),"\n",(0,o.jsxs)(i.p,{children:["Il flag ",(0,o.jsx)(i.code,{children:"CF"})," viene settato a 1 (0 altrimenti) se la somma, interpretata come somma fra naturali, produce riporto.\r\nIn altre parole, se il risultato naturale non sta sul numero di bit previsto, in questo caso 8, che pu\xf2 contenere solo naturali tra ",(0,o.jsx)(i.code,{children:"0"})," e ",(0,o.jsx)(i.code,{children:"255"}),".\r\nQuesto \xe8 il caso delle risposte ",(0,o.jsx)(i.em,{children:"b"})," e ",(0,o.jsx)(i.em,{children:"c"}),": per ",(0,o.jsx)(i.em,{children:"b"})," abbiamo ",(0,o.jsx)(i.code,{children:"128 + 128 = 256"}),", per ",(0,o.jsx)(i.em,{children:"c"})," ",(0,o.jsx)(i.code,{children:"255 + 1 = 256"}),", dove ",(0,o.jsx)(i.code,{children:"256 = 1_0000_0000"})," non sta su 8 bit.\r\nInvece, per ",(0,o.jsx)(i.em,{children:"a"})," abbiamo ",(0,o.jsx)(i.code,{children:"64 + 64 = 128"}),", ossia ",(0,o.jsx)(i.code,{children:"1000_0000"}),", che sta tranquillamente su 8 bit."]}),"\n",(0,o.jsxs)(i.p,{children:["Il flag ",(0,o.jsx)(i.code,{children:"OF"})," viene settato a 1 (0 altrimenti) se la somma, interpretata come somma fra interi, produce overflow.\r\nIn altre parole, se il risultato intero non sta sul numero di bit previsto, in questo caso 8, che pu\xf2 contenere solo interi (in CR) tra ",(0,o.jsx)(i.code,{children:"-128"})," e ",(0,o.jsx)(i.code,{children:"+127"}),".\r\nQuesto \xe8 il caso delle risposte ",(0,o.jsx)(i.em,{children:"a"})," e ",(0,o.jsx)(i.em,{children:"b"}),": per ",(0,o.jsx)(i.em,{children:"a"})," abbiamo ",(0,o.jsx)(i.code,{children:"64 + 64 = 128"}),", che in CR si rappresenta con ",(0,o.jsx)(i.code,{children:"0_1000_0000"}),", per ",(0,o.jsx)(i.em,{children:"b"})," abbiamo ",(0,o.jsx)(i.code,{children:"-128 + (-128) = -256"}),", che in CR si rappresenta come ",(0,o.jsx)(i.code,{children:"1_0000_000"}),".\r\nInvece, per ",(0,o.jsx)(i.em,{children:"c"})," abbiamo ",(0,o.jsx)(i.code,{children:"-1 + 1 = 0"}),", ossia ",(0,o.jsx)(i.code,{children:"0000_0000"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Dato che la ",(0,o.jsx)(i.em,{children:"b"})," verifica entrambi i criteri, \xe8 la risposta giusta."]}),"\n",(0,o.jsx)(i.h2,{id:"esercizi-per-casa",children:"Esercizi per casa"}),"\n",(0,o.jsxs)(i.p,{children:["Parte fondamentale delle esercitazioni \xe8 ",(0,o.jsx)(i.em,{children:"fare pratica"}),".\r\nPer questo, vengono lasciati alcuni esercizi per casa.\r\nLe soluzioni di alcuni di questi saranno discusse nelle esercitazioni successive."]}),"\n",(0,o.jsx)(i.h2,{id:"esercizio-12-istruzioni-stringa",children:"Esercizio 1.2: istruzioni stringa"}),"\n",(0,o.jsxs)(i.p,{children:["L'esercizio 1.1 compie un'operazione ripetuta su vettori.\r\nLegge da un vettore, una cella alla volta, ne manipola il contenuto, poi lo scrive su un altro vettore.\r\nQuesto genere di operazioni \xe8 adatto per l'uso delle ",(0,o.jsx)(i.em,{children:"istruzioni stringa"}),".\r\nRiscrivere quindi il programma sfruttando questo set di istruzioni:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"1. Leggere messaggio da terminale.\r\n2. Convertire le lettere minuscole in maiuscolo, usando le istruzioni stringa.\r\n3. Stampare messaggio modificato.\n"})}),"\n",(0,o.jsx)(i.h3,{id:"esercizi-13-e-14",children:"Esercizi 1.3 e 1.4"}),"\n",(0,o.jsx)(i.p,{children:"Scrivere dei programmi che si comportano come gli esercizi 1.1 e 1.2, tranne che per il fatto di convertire da maiuscolo in minuscolo anzich\xe9 il contrario."}),"\n",(0,o.jsx)(i.h3,{id:"esercizio-15",children:"Esercizio 1.5"}),"\n",(0,o.jsxs)(i.p,{children:["Scrivere un programma che, a partire dalla sezione ",(0,o.jsx)(i.code,{children:".data"})," che segue (e scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2025-26/code/assembler/1/per-casa/conta_num.s",children:"qui"}),"), conta e stampa il numero di occorrenze di ",(0,o.jsx)(i.code,{children:"numero"})," in ",(0,o.jsx)(i.code,{children:"array"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\n'})}),"\n",(0,o.jsx)(i.h3,{id:"esercizio-16",children:"Esercizio 1.6"}),"\n",(0,o.jsxs)(i.p,{children:["Quello che segue (e scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2025-26/code/assembler/1/per-casa/conta_num_debug.s",children:"qui"}),") \xe8 un tentativo di soluzione dell'esercizio precedente.\r\nContiene tuttavia uno o pi\xf9 bug. Trovarli e correggerli."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\r\n\r\n.text\r\n\r\n_main:\r\n    nop\r\n    mov $0, %cl\r\n    mov numero, %ax\r\n    mov $0, %esi\r\n\r\ncomp: \r\n    cmp array_len, %esi\r\n    je fine\r\n    cmpw array(%esi), %ax\r\n    jne poi\r\n    inc %cl\r\n\r\npoi:  \r\n    inc %esi\r\n    jmp comp\r\n\r\nfine: \r\n    mov %cl, %al\r\n    call outdecimal_byte\r\n    ret\n'})})]})}function m(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>c});var r=n(96540);const o={},a=r.createContext(o);function s(e){const i=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:i},e.children)}}}]);