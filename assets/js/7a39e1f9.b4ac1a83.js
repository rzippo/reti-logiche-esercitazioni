"use strict";(self.webpackChunkreti_logiche_esercitazioni=self.webpackChunkreti_logiche_esercitazioni||[]).push([[8778],{42921:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"esercitazioni/Verilog/Esercitazioni/Esercitazione 1","title":"Esercitazione 1","description":"","source":"@site/docs/esercitazioni/Verilog/Esercitazioni/1. Esercitazione 1.mdx","sourceDirName":"esercitazioni/Verilog/Esercitazioni","slug":"/esercitazioni/Verilog/Esercitazioni/Esercitazione 1","permalink":"/reti-logiche-esercitazioni/esercitazioni/Verilog/Esercitazioni/Esercitazione 1","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"description":""},"sidebar":"esercitazioniSidebar","previous":{"title":"Esercitazioni","permalink":"/reti-logiche-esercitazioni/category/esercitazioni-1"},"next":{"title":"Esercitazione 2","permalink":"/reti-logiche-esercitazioni/esercitazioni/Verilog/Esercitazioni/Esercitazione 2"}}');var a=n(74848),s=n(28453),r=n(86025);const t={description:""},c="Esercitazione 1",l={},d=[{value:"Da schemi circuitali a codice",id:"da-schemi-circuitali-a-codice",level:2},{value:"Concetto di testbench",id:"concetto-di-testbench",level:2},{value:"Full adder, descrizione e sintesi di reti combinatorie",id:"full-adder-descrizione-e-sintesi-di-reti-combinatorie",level:2}];function m(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"esercitazione-1",children:"Esercitazione 1"})}),"\n",(0,a.jsxs)(i.p,{children:["Per capire bene cos'\xe8 il Verilog \xe8 bene partire dal capire per cosa si usa.\n\xc8 un ",(0,a.jsx)(i.em,{children:"Hardware Description Language"}),", cio\xe8 un linguaggio formalizzato per la progettazione e realizzazione di componenti hardware: da reti combinatorie a CPU, architetture avanzate e componenti dedicati a scopi specifici."]}),"\n",(0,a.jsxs)(i.p,{children:["Lo scopo non \xe8 quindi ",(0,a.jsx)(i.em,{children:"solo"})," descrivere dell'hardware con del codice anzich\xe9 disegni, ma in generale supportare con strumenti utili l'ingegnere in tutte le fasi di progettazione di sistemi elettronici digitali, a partire dalla semplice prototizione dell'interfaccia (dove poco importa la realizzazione interna, ma solo l'algoritmo implementato), passando per la simulazione in testbench software, alla realizzazione fisica su FPGA e test in hardware."]}),"\n",(0,a.jsxs)(i.p,{children:["Tutti questi scopi hanno richieste diverse, e ",(0,a.jsx)(i.em,{children:"semantiche"})," relative diverse.\nPer questo non dovrebbe stupire il fatto che Verilog include molte diverse funzionalit\xe0 e sintassi che hanno senso solo in specifici contesti e non altri, che spazia dalle porte logiche elementari a strutture di programmazione stile-C e funzionalit\xe0 di stampa a terminale."]}),"\n",(0,a.jsxs)(i.p,{children:["Questo \xe8 spesso fonte di confusione, visto che il compilatore Verilog non aiuta a fare queste distinzioni, anzi, supporta intenzionalmente diversi modi di usare le stesse keyword, come ",(0,a.jsx)(i.code,{children:"reg"})," che pu\xf2 essere utilizzata sia come variabile di un programma che come un registro in una rete sincronizzata.\nCome vedremo, \xe8 importante tenere presente ",(0,a.jsx)(i.em,{children:"cosa"})," si sta facendo e ",(0,a.jsx)(i.em,{children:"perch\xe9"})," per poter capire quale forma e sintassi ha senso usare e quale no."]}),"\n",(0,a.jsx)(i.p,{children:"Noi vedremo 3 usi diversi, in particolare:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"descrizione e sintesi di reti combinatorie"}),"\n",(0,a.jsx)(i.li,{children:"descrizione e sintesi di reti sincronizzate"}),"\n",(0,a.jsx)(i.li,{children:"verifica con testbench simulativa"}),"\n"]}),"\n",(0,a.jsxs)(i.admonition,{title:"Argomenti d'esame",type:"info",children:[(0,a.jsxs)(i.p,{children:["Saper leggere o scrivere testbench ",(0,a.jsx)(i.em,{children:"non \xe8"})," parte degli argomenti d'esame.\n\xc8 tuttavia estremamente utile per esercitarsi provando con mano l'hardware descritto e capire come si comporta."]}),(0,a.jsxs)(i.p,{children:["Per ogni esercizio, cos\xec come in sede d'esame, viene ",(0,a.jsx)(i.em,{children:"fornita"})," una testbench adatta."]})]}),"\n",(0,a.jsx)(i.h2,{id:"da-schemi-circuitali-a-codice",children:"Da schemi circuitali a codice"}),"\n",(0,a.jsx)(i.p,{children:"La bussola fondamentale per scrivere Verilog \xe8 tenere sempre presente l'hardware che si vuole realizzare.\nPartiamo dall'idea di hardware che abbiamo tramite schemi, come nell'esempio in figura."}),"\n",(0,a.jsx)("img",{src:(0,r.Ay)("img/verilog/1/scatoletta.drawio.png"),alt:""}),"\n",(0,a.jsxs)(i.p,{children:["Questo schema mostra una generica rete combinatoria ",(0,a.jsx)(i.code,{children:"RC"})," con ingressi ",(0,a.jsx)(i.code,{children:"x"})," e ",(0,a.jsx)(i.code,{children:"y"}),", e uscite ",(0,a.jsx)(i.code,{children:"z"})," e ",(0,a.jsx)(i.code,{children:"w"}),".\nQuesta rete logica sar\xe0 implementata poi con componenti elettronici.\nSappiamo che questi, in quanto componenti fisici reali, non hanno un concetto di ordine tra di loro, o sincronizzazione, o attesa: gli ingressi ",(0,a.jsx)(i.code,{children:"x"})," e ",(0,a.jsx)(i.code,{children:"y"})," variano indipendentemente, possono avere cambiamenti anche contemparei e fluttuanti, e la rete ",(0,a.jsx)(i.code,{children:"RC"})," risponde sempre a questi cambiamenti tramite le uscite ",(0,a.jsx)(i.code,{children:"z"})," e ",(0,a.jsx)(i.code,{children:"w"}),", anche ",(0,a.jsx)(i.em,{children:"durante"})," i transitori dove gli ingressi variano da uno stato ad un altro.\nQuesta pu\xf2 sembrare una ripetizione banale se si pensa ai segnali elettrici che si propagano in un circuito, ma \xe8 facile dimenticarsene quando si guarda al codice Verilog.\nVediamo come questo schema si pu\xf2 tradurre in codice."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module RC(x, y, z, w);\n\ninput x, y;\noutput z, w;\n\nassign #1 z = x | y; \nassign #2 w = x & y; \n\nendmodule\n"})}),"\n",(0,a.jsxs)(i.p,{children:["In Verilog si dichiarano moduli in modo simile alle classi in linguaggi di programmazione: un modulo \xe8 un ",(0,a.jsx)(i.em,{children:"tipo"})," di componente che altri moduli potranno poi usare.\nLa riga 1 inizia la dichiarazione del modulo, che \xe8 composta dal nome del modulo (",(0,a.jsx)(i.code,{children:"RC"}),") e dalla lista di porte di questo modulo, anch'esse con nome (",(0,a.jsx)(i.code,{children:"x"}),", ",(0,a.jsx)(i.code,{children:"y"}),", ",(0,a.jsx)(i.code,{children:"z"}),", ",(0,a.jsx)(i.code,{children:"w"}),").\nQueste porte possono essere di input e/o output, a uno o a pi\xf9 bit.\nSpecifichiamo questo alle righe 3 e 4. Mancando indicazioni di dimensione, saranno tutte da 1 bit.\nAlle righe 6 e 7 specifichiamo il comportamento dei fili di uscita ",(0,a.jsx)(i.code,{children:"z"})," e ",(0,a.jsx)(i.code,{children:"w"}),".\nLo statement ",(0,a.jsx)(i.code,{children:"assign"})," indica che l'elemento a sinistra assume continuamente il valore indicato dall'espressione a destra.\nCon ",(0,a.jsx)(i.code,{children:"#1"})," si indica un fattore di ritardo nell'aggiornamento, di 1 unit\xe0\tdi tempo.\nOgni rete combinatoria che non sia un semplice filo ha un certo tempo di attraversamento non trascurabile, ed \xe8 importante rappresentarlo con un elemento di ritardo."]}),"\n",(0,a.jsxs)(i.p,{children:["Nel codice, vediamo che l'",(0,a.jsx)(i.code,{children:"assign"})," di ",(0,a.jsx)(i.code,{children:"z"})," precede quello di ",(0,a.jsx)(i.code,{children:"w"}),".\nQuesto per\xf2 non ha nulla a che vedere con le propriet\xe0 temporali che li legano: con queste linee di codice rappresentiamo componenti hardware distinti che si evolvono continuamente, indipendentemente e contemporaneamente.\nL'ordine degli statement di un ",(0,a.jsx)(i.code,{children:"module"})," ha lo stesso valore dell'ordine con cui si disegnano le linee di uno schema circuitale: completamente irrilevante ai fini del risultato finale.\nQuesto rimarr\xe0 vero quando vedremo reti pi\xf9 complesse, dove dimenticarsi di questo porta a errori gravi."]}),"\n",(0,a.jsx)(i.h2,{id:"concetto-di-testbench",children:"Concetto di testbench"}),"\n",(0,a.jsxs)(i.p,{children:["Abbiamo progettato il nostro hardware, la rete ",(0,a.jsx)(i.code,{children:"RC"})," di cui sopra.\nVogliamo sapere per\xf2 come si comporta, e in particolare se fa quello che ci aspettiamo dalle specifiche.\nPer far questo, ho bisogno di mettere ",(0,a.jsx)(i.code,{children:"RC"})," in un contesto in cui ne manipolo gli ingressi in un modo noto, cos\xec da conoscere quali output aspettarsi, e con della logica apposita misuro le uscite e verifico che corrispondano a quelle attese.\nTale ambiente \xe8 quello che chiamamo ",(0,a.jsx)(i.em,{children:"testbench"}),".\nNell'esempio in figura, una rete ",(0,a.jsx)(i.code,{children:"check"})," controlla le uscite e con l'uscita ",(0,a.jsx)(i.code,{children:"ok"})," indica se il test \xe8 andato a buon fine o no."]}),"\n",(0,a.jsx)("img",{src:(0,r.Ay)("img/verilog/1/testbench_hw.drawio.png"),alt:""}),"\n",(0,a.jsx)(i.admonition,{type:"tip",children:(0,a.jsxs)(i.p,{children:["Il corrispettivo nel mondo software \xe8 un programma di test che prova i metodi e strutture dati di una libreria. Anche noto come ",(0,a.jsx)(i.em,{children:"unit test"}),"."]})}),"\n",(0,a.jsxs)(i.p,{children:["Una opzione \xe8 progettare questa testbench come un ulteriore componente hardware, e seguire tutti i passaggi necessari a realizzare ",(0,a.jsx)(i.em,{children:"con hardware vero"})," la testbench con dentro la rete sopra descritta, per esempio con FPGA.\nQuesto \xe8 sicuramente corretto, ma molto costoso, quantomeno nel tempo necessario a fare la verifica.\nUna opzione pi\xf9 interessante \xe8 usare la ",(0,a.jsx)(i.em,{children:"simulazione"}),": si ",(0,a.jsx)(i.em,{children:"compila"})," un programma eseguibile che simula il comportamento dell'hardware, almeno fino ad un certo livello di dettaglio.\nQuesto ci da un responso in modo molto pi\xf9 efficiente, visto che si pu\xf2 modificare, ricompilare e rieseguire in pochi secondi vedendo il risultato direttamente a terminale."]}),"\n",(0,a.jsxs)(i.p,{children:["Si pu\xf2 fare un passo in pi\xf9: anzich\xe9 progettare la testbench come dell'altro hardware con semplice uscita ",(0,a.jsx)(i.code,{children:"ok"}),", si sfrutta appieno la natura software della simulazione per scrivere qualcosa che \xe8 pi\xf9 simile ad un ",(0,a.jsx)(i.em,{children:"programma di test"}),", dove abbiamo effettivamente ordine e temporazzazione tra gli statement, insieme ad altri concetti che sarebbero privi di senso al di fuori della simulazione.\nQuesto ci fornisce un modo per fare ",(0,a.jsx)(i.em,{children:"debugging"})," su descrizioni di hardware."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-verilog",metastring:"showLineNumbers",children:'module testbench();\n    reg x_t, y_t; // "variabili"\n    wire z_t, w_t;\n\n    RC rc (\n        .x(x_t), .y(y_t),\n        .z(z_t), .w(w_t)\n    );\n\n    initial begin\n        $dumpfile("waveform.vcd");\n        $dumpvars;\n\n        x_t = 0; \n        y_t = 0;\n        #10;\n        if (z_t == 0 && w_t == 0)\n            $display("0 0 -> 0 0 success");\n        else\n            $display("0 0 -> 0 0 fail");\n\n        x_t = 0; \n        y_t = 1;\n        #10;\n        if (z_t == 0 && w_t == 1)\n            $display("0 1 -> 0 1 success");\n        else\n            $display("0 1 -> 0 1 fail");\n\n        x_t = 1; \n        y_t = 0;\n        #10;\n        if (z_t == 0 && w_t == 1)\n            $display("1 0 -> 0 1 success");\n        else\n            $display("1 0 -> 0 1 fail");\n\n        x_t = 1; \n        y_t = 1;\n        #10;\n        if (z_t == 1 && w_t == 1)\n            $display("1 1 -> 1 1 success");\n        else\n            $display("1 1 -> 1 1 fail");\n\n    end\nendmodule\n'})}),"\n",(0,a.jsxs)(i.p,{children:["Le righe da 2 a 8 sono molto vicine a quello che vediamo nel disegno.\nDichiariamo dei ",(0,a.jsx)(i.code,{children:"reg"})," che useremo per pilotare gli ingressi della rete combinatoria, e dei ",(0,a.jsx)(i.code,{children:"wire"})," che useremo per monitorarne le uscite.\nDichiariamo poi la nostra rete combinatoria: lo statement a righe 5-8 \xe8 nella forma ",(0,a.jsx)(i.code,{children:"tipo_modulo nome_istanza( [lista porte] );"}),".\nPossiamo immaginare questo statement come equivalente dell'atto fisico di prendere un chip di tipo ",(0,a.jsx)(i.code,{children:"RC"}),", che chiameremo con un nome d'istanza ",(0,a.jsx)(i.code,{children:"rc"})," per distinguerlo dagli altri, e posizionarlo nella nostra rete collegandone i vari piedini con altri elementi: l'ingresso ",(0,a.jsx)(i.code,{children:"x"})," al ",(0,a.jsx)(i.code,{children:"reg"})," ",(0,a.jsx)(i.code,{children:"x_t"}),", l'uscita ",(0,a.jsx)(i.code,{children:"z"})," al ",(0,a.jsx)(i.code,{children:"wire"})," ",(0,a.jsx)(i.code,{children:"z_t"}),", e cos\xec via."]}),"\n",(0,a.jsxs)(i.p,{children:["La notazione mostrata a righe 6-7 \xe8 con parametri nominati (",(0,a.jsx)(i.em,{children:"named parameters"}),"), dove si indicano esplicitamente gli assegnamenti tra parametro del componente e componente esterno.\nSi pu\xf2 sempre utilizzare l'alternativa pi\xf9 nota - perch\xe9 unica scelta in molti linguaggi, come C - ossia la notazione con parametri posizionali (",(0,a.jsx)(i.em,{children:"positional parameters"}),"), dove l'associazione \xe8 data dalla corrispondenza con l'ordine di dichiarazione dei parametri."]}),"\n",(0,a.jsxs)(i.admonition,{title:"Evitare parametri posizionali",type:"tip",children:[(0,a.jsxs)(i.p,{children:["La notazione con parametri posizionali pu\xf2 sembrare meno prolissa, ma \xe8 anche pi\xf9 pericolosa.\nIn primo luogo, si basa sul fatto di ricordarsi ",(0,a.jsx)(i.em,{children:"esattamente"})," l'ordine dei parametri, quando \xe8 invece facile distrarsi e scambiarli di posto.\nIn secondo luogo, non permette di ",(0,a.jsx)(i.em,{children:"saltare"})," una posizione, mentre vedremo esempi dove collegare qualcosa ad una o pi\xf9 uscite di una rete \xe8 del tutto opzionale."]}),(0,a.jsx)(i.p,{children:"Queste limitazioni possono sembrare semplici da aggirare, ma il vero problema \xe8 che ad una semplice svista su un assegnamento di parametri posizionali corrisponde una lunga e faticosa fase di debug in cui tutto sembra comportarsi in modo completamente casuale."})]}),"\n",(0,a.jsxs)(i.p,{children:["Guardando le righe successive, ci sono diversi concetti che hanno un senso ",(0,a.jsx)(i.em,{children:"in questo contesto"})," mentre altrove o hanno un senso ",(0,a.jsx)(i.em,{children:"diverso"})," o sono del tutto privi di senso.\nIniziamo dall'uso di ",(0,a.jsx)(i.code,{children:"reg"})," come variabili, assegnando valori in serie come in un programma C.\nNelle reti sincronizzate, vedremo che ",(0,a.jsx)(i.code,{children:"reg"})," viene usato con significato e comportamento completamente diverso.\nVediamo poi che usiamo un blocco ",(0,a.jsx)(i.code,{children:"initial begin ... end"}),": questo contiene degli statement, eseguiti come un programma uno alla volta, separati talvolta da delle attese esplicite come ",(0,a.jsx)(i.code,{children:"#10"})," che attende 10 unit\xe0 di tempo.\nIl termine ",(0,a.jsx)(i.code,{children:"initial"})," significa che il programma \xe8 eseguito \"all'inizio della simulazione\": questo \xe8 un esempio di concetto completamente insensato per dell'hardware, dove ",(0,a.jsx)("u",{children:"non esiste"})," un tempo 0.\nAltri statement che hanno senso solo in una simulazione sono ",(0,a.jsx)(i.code,{children:"$display"}),", che stampa a terminale, e ",(0,a.jsx)(i.code,{children:"$dumpfile"})," e ",(0,a.jsx)(i.code,{children:"$dumpvars"}),", che producono invece un file ",(0,a.jsx)(i.code,{children:"waveform.vcd"})," che possiamo studiare con ",(0,a.jsx)(i.code,{children:"GTKWave"}),"."]}),"\n",(0,a.jsxs)(i.p,{children:["Leggendo il codice come un programma, vediamo che questa testbench altro non fa che testare tutti e 4 i possibili stati di ",(0,a.jsx)(i.code,{children:"x"})," e ",(0,a.jsx)(i.code,{children:"y"}),", confrontando le uscite ",(0,a.jsx)(i.code,{children:"z"})," e ",(0,a.jsx)(i.code,{children:"w"})," con i valori attesi."]}),"\n",(0,a.jsx)(i.admonition,{title:"Unit\xe0 di tempo",type:"info",children:(0,a.jsxs)(i.p,{children:["Le unit\xe0 temporali (sia di default che di volta in volta) si possono specificare, ma noi per semplicit\xe0 non lo facciamo.\nCome vedremo dalle waveform, di conseguenza ogni valore viene interpretato di default come ",(0,a.jsx)(i.em,{children:"secondi"}),", cosa decisamente poco realistica, ma comunque di nessun impatto per i nostri usi."]})}),"\n",(0,a.jsxs)(i.p,{children:["Per eseguire il test useremo tre programmi: ",(0,a.jsx)(i.code,{children:"iverilog"})," e ",(0,a.jsx)(i.code,{children:"vvp"}),", dalla suite ",(0,a.jsx)(i.a,{href:"https://github.com/steveicarus/iverilog",children:"Icarus Verilog"}),", e ",(0,a.jsx)(i.code,{children:"GTKWave"}),".\nA differenza dell'ambiente per Assembler, questi sono facilmente reperibili per ogni piattaforma, o compilabili dal sorgente.\n",(0,a.jsx)(i.a,{href:"https://bleyer.org/icarus/",children:"Qui"})," si trovano installer per Windows."]}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.code,{children:"iverilog"})," \xe8 il programma che ",(0,a.jsx)(i.em,{children:"compila"})," la nostra simulazione. La sintassi \xe8 la seguente:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"iverilog -o nome_simulazione testbench.v mia_rete.v [altri file .v]\n"})}),"\n",(0,a.jsxs)(i.p,{children:["I file per questo test sono scaricabili ",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(80451).A+"",children:"qui"})," e ",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(80858).A+"",children:"qui"}),".\nIl file prodotto da ",(0,a.jsx)(i.code,{children:"iverilog"})," non \xe8 direttamente eseguibile, ma va eseguito usando ",(0,a.jsx)(i.code,{children:"vvp"}),":"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"vvp nome_simulazione\n"})}),"\n",(0,a.jsx)(i.p,{children:"Otteniamo un output come il seguente:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"VCD info: dumpfile waveform.vcd opened for output.\n0 0 -> 0 0 success\n0 1 -> 0 1 fail\n1 0 -> 0 1 fail\n1 1 -> 1 1 success\n"})}),"\n",(0,a.jsxs)(i.p,{children:["La prima riga \xe8 relativa ai comandi ",(0,a.jsx)(i.code,{children:"$dumpfile"})," e ",(0,a.jsx)(i.code,{children:"$dumpvars"}),", ci informa semplicemente che la simulazione sta effettivamente salvando i dati su ",(0,a.jsx)(i.code,{children:"waveform.vcd"}),".\nLe righe successive sono invece quelle stampate dai nostri ",(0,a.jsx)(i.code,{children:"$display"}),": vediamo che alcuni test sono falliti."]}),"\n",(0,a.jsx)(i.admonition,{title:"Stampe a fine simulazione",type:"note",children:(0,a.jsxs)(i.p,{children:["Alcune versioni di ",(0,a.jsx)(i.code,{children:"iverilog"})," aggiungono ",(0,a.jsx)(i.em,{children:"di default"}),' una stampa del tipo "$finish called at ..." al termine della simulazione, altre no.']})}),"\n",(0,a.jsx)(i.admonition,{title:"Chi ha ragione?",type:"tip",children:(0,a.jsx)(i.p,{children:"Un test che fallisce indica soltanto che il codice di test e il codice testato sono in disaccordo.\nLa maggior parte delle volte, se fatto bene, il test rappresenta la specifica desiderata, mentre ci\xf2 che \xe8 testato ne indica solo l'implementazione.\nPer questo, di solito, ha ragione il test e va cambiato ci\xf2 che \xe8 testato."})}),"\n",(0,a.jsxs)(i.p,{children:["Cerchiamo di capire perch\xe9 il test fallisce, e quindi in cosa la rete ",(0,a.jsx)(i.code,{children:"RC"})," non segue la specifica.\nLe stampe ci indicano i valori attesi e il fatto che non corrispondono con quelli prodotti da ",(0,a.jsx)(i.code,{children:"RC"}),", non quali valori sono stati trovati in ",(0,a.jsx)(i.code,{children:"z"})," e ",(0,a.jsx)(i.code,{children:"w"}),".\nPotremmo cambiare le stampe per includerlo, ma \xe8 facile intuire che questo approccio non scala bene: non possiamo stampare a schermo tutte le variabili in tutte le situazioni.\n\xc8 per questo che si usa la waveform.\nLanciamo GTKWave con il comando"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"gtkwave waveform.vcd\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Si dovrebbe aprire quindi una finestra dal quale possiamo analizzare l'evoluzione della rete, filo per filo, nel tempo.\nEspandiamo le reti nel menu a sinistra, selezioniamo la rete ",(0,a.jsx)(i.code,{children:"rc"})," e quindi gli input ",(0,a.jsx)(i.code,{children:"x"})," e ",(0,a.jsx)(i.code,{children:"y"})," e gli output ",(0,a.jsx)(i.code,{children:"z"})," e ",(0,a.jsx)(i.code,{children:"w"}),", clicchiamo poi ",(0,a.jsx)(i.em,{children:"Append"}),".\nOtteniamo una schermata come quella in figura."]}),"\n",(0,a.jsx)("img",{src:(0,r.Ay)("img/verilog/1/waveform_1.png"),alt:""}),"\n",(0,a.jsx)(i.p,{children:"La schermata mostra l'evoluzione nel tempo dei fili selezionati, in particolare nel momento selezionato (la linea verticale rossa)."}),"\n",(0,a.jsxs)(i.admonition,{title:"Significato delle waveform",type:"tip",children:[(0,a.jsxs)(i.p,{children:["GTKWave usa linee verdi con valore alto o basso per elementi da un singolo bit che hanno valore ",(0,a.jsx)(i.em,{children:"logico"})," 0 o 1.\nIn caso di elemento da pi\xf9 bit, utilizza linee verdi sopra e sotto il valore corrente dell'elemento (si pu\xf2 cambiare come sono interpretati i bit usando il menu contestuale)."]}),(0,a.jsxs)(i.p,{children:["Le aree di colore rosso indicano punti in cui il valore logico \xe8 ",(0,a.jsx)(i.em,{children:"non specificato"}),", ",(0,a.jsx)(i.code,{children:"'bx"}),", tipicamente perch\xe9 uno o pi\xf9 bit dell'elemento non sono unicamente determinabili.\nUna linea in mezzo di colore giallo vuol dire invece ",(0,a.jsx)(i.em,{children:"alta impedenza"}),", ",(0,a.jsx)(i.code,{children:"'bz"}),", che ",(0,a.jsx)("u",{children:"non \xe8 un valore logico"})," e vuol dire che, elettricamente, il filo non \xe8 connesso.\nSia ",(0,a.jsx)(i.code,{children:"'bx"})," che ",(0,a.jsx)(i.code,{children:"'bz"})," hanno contesti ed usi utili in cui \xe8 normale che compaiano, ma ",(0,a.jsx)(i.em,{children:"molto spesso"})," sono sintomo di un errore e un buon punto di partenza per il debug."]})]}),"\n",(0,a.jsxs)(i.p,{children:["Vediamo dalla waveform i valori di ",(0,a.jsx)(i.code,{children:"w"})," e ",(0,a.jsx)(i.code,{children:"z"})," in corrispondenza dei test falliti: in entrambi i casi il test richiede ",(0,a.jsx)(i.code,{children:"z"})," a 0 e lo trova a 1, ",(0,a.jsx)(i.code,{children:"w"})," a 1 e lo trova a 0.\nNotiamo quindi che il test si aspetta che ",(0,a.jsx)(i.code,{children:"z"})," si comporti come un AND e ",(0,a.jsx)(i.code,{children:"w"})," come un OR, mentre vediamo che succede il contrario.\nDobbiamo quindi scambiare gli ",(0,a.jsx)(i.code,{children:"assign"})," delle due uscite."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-verilog",children:"module RC(x, y, z, w);\n\ninput x, y;\noutput z, w;\n\nassign #1 z = x & y; \nassign #2 w = x | y; \n\nendmodule\n"})}),"\n",(0,a.jsxs)(i.admonition,{title:"Usare il reload in GTKWave",type:"tip",children:[(0,a.jsxs)(i.p,{children:["Una volta cambiato il codice, vorremmo ricompilare e rieseguire la simulazione.\nMa il comando ",(0,a.jsx)(i.code,{children:"gtkwave waveform.vcd"})," blocca il terminale finch\xe9 non chiudiamo la finestra.\nPotremmo chiudere GTKWave e riavvarlo dopo, ma questo significa rifare daccapo tutto il setup per analizzare le waveform."]}),(0,a.jsx)(i.p,{children:"\xc8 per questo una buona idea utilizzare una delle seguenti strategie:"}),(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["usare due terminali, uno dedicato a ",(0,a.jsx)(i.code,{children:"iverilog"})," e ",(0,a.jsx)(i.code,{children:"vvp"}),", l'altro a ",(0,a.jsx)(i.code,{children:"gtkwave"})]}),"\n",(0,a.jsxs)(i.li,{children:["lanciare il comando in background. Nell'ambiente Windows all'esame, questo si pu\xf2 fare con un ",(0,a.jsx)(i.code,{children:"&"})," in fondo: ",(0,a.jsx)(i.code,{children:"gtkwave waveform.vcd &"})]}),"\n"]}),(0,a.jsx)(i.p,{children:"In entrambi i casi, otteniamo di poter rieseguire la simulazione mentre GTKWave \xe8 aperto. Possiamo quindi sfruttare il pulsante Reload, che caricher\xe0 le nuove waveform dall'ultima simulazione senza dover reimpostare l'interfaccia."}),(0,a.jsxs)(i.admonition,{type:"warning",children:[(0,a.jsxs)(i.mdxAdmonitionTitle,{children:["Se l'operatore ",(0,a.jsx)(i.code,{children:"&"})," non funziona"]}),(0,a.jsxs)(i.p,{children:["In alcune installazioni di Powershell l'operatore ",(0,a.jsx)(i.code,{children:"&"})," non funziona.\nL'operatore \xe8 un semplice alias per ",(0,a.jsx)(i.code,{children:"Start-Job"}),", e si pu\xf2 ovviare al problema usando questo comando per esteso:"]}),(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"Start-Job { gtkwave waveform.vcd }\n"})}),(0,a.jsxs)(i.p,{children:["L'operatore \xe8 documentato ",(0,a.jsx)(i.a,{href:"https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operators?view=powershell-7.4#background-operator-",children:"qui"}),"."]})]})]}),"\n",(0,a.jsx)(i.h2,{id:"full-adder-descrizione-e-sintesi-di-reti-combinatorie",children:"Full adder, descrizione e sintesi di reti combinatorie"}),"\n",(0,a.jsxs)(i.p,{children:["In generale, la differenza tra ",(0,a.jsx)(i.em,{children:"descrizione"})," e ",(0,a.jsx)(i.em,{children:"sintesi"})," \xe8 la seguente: una descrizione si limita a dire cosa una rete ",(0,a.jsx)(i.em,{children:"fa"}),", senza scendere oltre nei dettagli implementativi; una sintesi mostra invece ",(0,a.jsx)(i.em,{children:"come si implementa"})," questo comportamento.\nUna sintesi \xe8 un modo di realizzare una rete che si comporta come indicato dalla descrizione, e ci possono essere diversi modi (seguendo diversi modelli, algoritmi, criteri di costo) per sintetizzare una descrizione."]}),"\n",(0,a.jsxs)(i.p,{children:["Per il caso delle reti combinatorie, vediamo l'esampio del ",(0,a.jsx)(i.em,{children:"full adder"}),", partendo dal caso a 1 bit (",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(66366).A+"",children:"testbench"}),", ",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(69082).A+"",children:"descrizione"}),", ",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(62280).A+"",children:"sintesi"}),")."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module full_adder(\n    x, y, c_in,\n    s, c_out\n);\n    input x, y;\n    input c_in;\n    output s;\n    output c_out;\n\n    assign #5 {c_out, s} = x + y + c_in;\nendmodule\n"})}),"\n",(0,a.jsx)(i.admonition,{title:"Sintassi: raggruppamento",type:"info",children:(0,a.jsxs)(i.p,{children:["Le parentesi graffe, come in ",(0,a.jsx)(i.code,{children:"{c_out, s}"}),", si pu\xf2 usare per raggruppare elementi sia a destra che a sinistra di un assegnamento.\nBisogna stare per\xf2 attenti alle dimensioni in bit, e cosa viene assegnato a cosa."]})}),"\n",(0,a.jsxs)(i.p,{children:["Questa \xe8 una ",(0,a.jsx)(i.em,{children:"descrizione"})," del full adder: ci spiega cosa fa questo modulo, indicando le porte e la relazione tra ingressi e uscite, ma non ci dice nulla su come \xe8 implementata questa relazione.\nInfatti, la riga 10 utilizza l'operatore ",(0,a.jsx)(i.code,{children:"+"})," del linguaggio Verilog, non ci spiega ",(0,a.jsx)(i.em,{children:"come si fa"})," la somma.\nQuando si usano espressioni in questo modo, il compilatore Verilog non le traduce in hardware, ma ne calcola direttamente il risultato usando la nostra CPU a tempo di simulazione."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module full_adder(\n    x, y, c_in,\n    s, c_out\n);\n    input x, y;\n    input c_in;\n    output s;\n    output c_out;\n\n    assign #5 s = x ^ y ^ c_in;\n    assign #5 c_out = ( x & y ) | ( y & c_in) | ( x & c_in );\nendmodule\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Questa invece \xe8 una ",(0,a.jsx)(i.em,{children:"sintesi"}),": ci mostra come realizzare il sommatore usando operatori logici elementari."]}),"\n",(0,a.jsxs)(i.p,{children:["Un altro modo per definire ",(0,a.jsx)(i.em,{children:"sintesi"})," \xe8 il fatto che siamo in grado, a partire dalla sintesi, di produrre lo schema circuitale corrispondente.\nInfatti, dal codice sopra possiamo ricavare il seguente schema."]}),"\n",(0,a.jsx)("img",{src:(0,r.Ay)("img/verilog/1/full-adder-1.drawio.png"),alt:""}),"\n",(0,a.jsxs)(i.p,{children:["Vediamo ora il caso di un full adder a 3 bit (",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(63270).A+"",children:"testbench"}),", ",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(7262).A+"",children:"descrizione"}),", ",(0,a.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(67180).A+"",children:"sintesi"}),")."]}),"\n",(0,a.jsx)(i.p,{children:"Per una descrizione, ci basta seguire l'esempio del caso a 1 bit, con l'aggiunta delle diverse dimensioni dei fili."}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module full_adder_3(\n    x, y, c_in,\n    s, c_out\n);\n    input [2:0] x, y;\n    input c_in;\n    output [2:0] s;\n    output c_out;\n\n    assign #5 {c_out, s} = x + y + c_in;\nendmodule\n"})}),"\n",(0,a.jsx)(i.admonition,{title:"Sintassi: elementi di pi\xf9 bit",type:"info",children:(0,a.jsxs)(i.p,{children:["La dichiarazione con ",(0,a.jsx)(i.code,{children:"[2:0]"})," indica che l'elemento \xe8 composto da 3 bit, indicizzati da 0 a 2.\nQuesti indici possono poi essere utilizzati per selezionare uno pi\xf9 di componenti.\nPer esempio, con ",(0,a.jsx)(i.code,{children:"x[2:1]"})," si selezionano i bit 2 e 1 di ",(0,a.jsx)(i.code,{children:"x"}),", con ",(0,a.jsx)(i.code,{children:"x[1]"})," solo il bit 1."]})}),"\n",(0,a.jsx)(i.p,{children:"Come prima, questa \xe8 una descrizione perch\xe9 non ci dice affatto come realizzare il sommatore, e non possiamo disegnare uno schema circuitale a partire da questo codice senza sapere gi\xe0, da un'altra fonte, come realizzare un full adder a 3 bit."}),"\n",(0,a.jsx)(i.p,{children:"Passiamo invece alla sintesi. Sappiamo che il full adder \xe8 un esempio di rete componibile, nel senso che possiamo realizzare un full adder a N bit usando N full adder a 1 bit.\nVediamo come partendo, questa volta, dallo schema circuitale."}),"\n",(0,a.jsx)("img",{src:(0,r.Ay)("img/verilog/1/full-adder-3.drawio.png"),alt:""}),"\n",(0,a.jsx)(i.p,{children:"Da questo schema, si evince che sappiamo realizzare un full adder a 3 bit se sappiamo gi\xe0 realizzare un full adder a 1 bit.\nQuesta relazione si conserva anche nel codice Verilog: nella sintesi di una rete combinatoria si possono utilizzare altre reti combinatorie di cui, a loro volta, si conosce la sintesi."}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module full_adder_3(\n    x, y, c_in,\n    s, c_out\n);\n    input [2:0] x, y;\n    input c_in;\n    output [2:0] s;\n    output c_out;\n\n    wire c_in_1;\n    full_adder fa_0 (\n        .x(x[0]), .y(y[0]), .c_in(c_in),\n        .s(s[0]), .c_out(c_in_1)\n    );\n\n    wire c_in_2;\n    full_adder fa_1 (\n        .x(x[1]), .y(y[1]), .c_in(c_in_1),\n        .s(s[1]), .c_out(c_in_2)\n    );\n\n    full_adder fa_2 (\n        .x(x[2]), .y(y[2]), .c_in(c_in_2),\n        .s(s[2]), .c_out(c_out)\n    );\n\nendmodule\n"})}),"\n",(0,a.jsxs)(i.p,{children:["In questo codice riutilizziamo la rete ",(0,a.jsx)(i.code,{children:"full_adder"})," che abbiamo sintetizzato prima.\nNotiamo come per farlo dobbiamo instanziare la rete tre volte, dandogli nomi diversi (",(0,a.jsx)(i.code,{children:"fa_0"}),", ",(0,a.jsx)(i.code,{children:"fa_1"}),", ",(0,a.jsx)(i.code,{children:"fa_2"}),"), e dichiarare dei nuovi ",(0,a.jsx)(i.code,{children:"wire"})," per collegarli, ",(0,a.jsx)(i.code,{children:"c_in_1"})," e ",(0,a.jsx)(i.code,{children:"c_in_2"}),".\nInfine, utilizziamo indici per indicare le componenti di ",(0,a.jsx)(i.code,{children:"x"})," e ",(0,a.jsx)(i.code,{children:"y"})," da collegare a ciascun ",(0,a.jsx)(i.code,{children:"full_adder"}),", cos\xec come quale componente di ",(0,a.jsx)(i.code,{children:"s"})," \xe8 collegata a quale uscita."]}),"\n",(0,a.jsxs)(i.p,{children:["Di nuovo, possiamo vedere la corrispondenza tra il codice Verilog e lo schema circuitale: questo non \xe8 un caso, anzi \xe8 ",(0,a.jsx)("u",{children:"fondamentale"}),".\nTolto il caso limite delle testbench simulative, ogni cosa che scriviamo in Verilog ha senso ",(0,a.jsx)("u",{children:"solo"})," se ci \xe8 chiaro che tipo di hardware corrisponde a ci\xf2 che scriviamo e come si pu\xf2 realizzare."]}),"\n",(0,a.jsxs)(i.p,{children:["Questo vale anche quando si fa una descrizione.\nPer esempio, abbiamo prima visto come si pu\xf2 descrivere un full adder scrivendo ",(0,a.jsx)(i.code,{children:"{c_out, s} = x + y + c_in"}),".\nQuesto ci permette di essere meno prolissi, a patto che si sa come si fa un sommatore.\nVedremo pi\xf9 avanti, nelle reti sincronizzate, esempi di cose che sono semplici da scrivere in descrizione, affidandosi al simulatore per eseguirne la logica, ma che si rivelano poi ",(0,a.jsx)(i.em,{children:"molto difficili"})," da sintetizzare."]})]})}function u(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},7262:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/full-adder-3-descrizione-26ab7db66421b15ff3c7f324d9755682.v"},67180:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/full-adder-3-sintesi-51aa0528250fa0492d5e7e4ca27642a0.v"},63270:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/testbench-3-b0f6f28d4268fcd9f30ef5a21c067dad.v"},69082:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/full-adder-descrizione-7bec6dcf6c641be51ff3a6be6f9452d2.v"},62280:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/full-adder-sintesi-5f28869ddd550ddaba1e09dd7924c2b6.v"},66366:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/testbench-7775a87a7d990901efbd4a9e5f1a8ec2.v"},80858:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/rc-877cfbbc13e3d3f181960cfa3a3019dd.v"},80451:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/files/testbench-98f381457aa49d8fe1e5a254810cf1dc.v"},28453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>t});var o=n(96540);const a={},s=o.createContext(a);function r(e){const i=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(s.Provider,{value:i},e.children)}}}]);