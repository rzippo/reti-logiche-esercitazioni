"use strict";(self.webpackChunkreti_logiche_esercitazioni=self.webpackChunkreti_logiche_esercitazioni||[]).push([[2435],{39711:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"esercitazioni/Assembler/Esercitazioni/Esercitazione 2old","title":"Esercitazione 2old","description":"","source":"@site/versioned_docs/version-2025-26/esercitazioni/Assembler/Esercitazioni/2. Esercitazione 2old.mdx","sourceDirName":"esercitazioni/Assembler/Esercitazioni","slug":"/esercitazioni/Assembler/Esercitazioni/Esercitazione 2old","permalink":"/reti-logiche-esercitazioni/esercitazioni/Assembler/Esercitazioni/Esercitazione 2old","draft":false,"unlisted":true,"tags":[],"version":"2025-26","sidebarPosition":2,"frontMatter":{"description":"","unlisted":true},"sidebar":"esercitazioniSidebar"}');var r=i(74848),s=i(28453),o=i(86025);const l={description:"",unlisted:!0},c="Esercitazione 2",t={},d=[{value:"Soluzioni passo-passo esercizi per casa",id:"soluzioni-passo-passo-esercizi-per-casa",level:2},{value:"Esercizio 1.2: istruzioni stringa, soluzione passo-passo",id:"esercizio-12-istruzioni-stringa-soluzione-passo-passo",level:3},{value:"Esercizio 1.6: esercizio di debugging, soluzione passo-passo",id:"esercizio-16-esercizio-di-debugging-soluzione-passo-passo",level:3},{value:"Esercizio 1.8: soluzione passo-passo",id:"esercizio-18-soluzione-passo-passo",level:3},{value:"Esercizio 2.1: esercizio d&#39;esame 2022-01-26",id:"esercizio-21-esercizio-desame-2022-01-26",level:2},{value:"Esercizi per casa",id:"esercizi-per-casa",level:2},{value:"Esercizio 1.7",id:"esercizio-17",level:3},{value:"Esercizio 1.8",id:"esercizio-18",level:3},{value:"Esercizio 2.2",id:"esercizio-22",level:3},{value:"Esercizio 2.3",id:"esercizio-23",level:3}];function m(e){const n={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"esercitazione-2",children:"Esercitazione 2"})}),"\n",(0,r.jsx)(n.h2,{id:"soluzioni-passo-passo-esercizi-per-casa",children:"Soluzioni passo-passo esercizi per casa"}),"\n",(0,r.jsx)(n.h3,{id:"esercizio-12-istruzioni-stringa-soluzione-passo-passo",children:"Esercizio 1.2: istruzioni stringa, soluzione passo-passo"}),"\n",(0,r.jsx)(n.p,{children:"Ricordiamo la traccia dell'esercizio:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Leggere messaggio da terminale.\r\n2. Convertire le lettere minuscole in maiuscolo, usando le istruzioni stringa.\r\n3. Stampare messaggio modificato.\n"})}),"\n",(0,r.jsx)(n.p,{children:"Le istruzioni stringa sono un esempio di set di istruzioni specializzate, cio\xe8 istruzioni che non sono pensate per implementare algoritmi generici, ma sono invece pensate per fornire supporto hardware efficiente a uno specifico set di operazioni che alcuni algoritmi necessitano.\r\nInfatti, ci si pu\xf2 aspettare che tra due programmi equivalenti, uno scritto con sole istruzioni generali e l'altro scritto con istruzioni specializzate, il secondo sar\xe0 molto pi\xf9 performante del primo.\r\nAltri esempi comuni sono le istruzioni a supporto di crittografia, encoding e decoding di stream multimediali, e, pi\xf9 recentemente, neural networks."}),"\n",(0,r.jsx)(n.p,{children:"Questi set di istruzioni sono per\xf2 pi\xf9 \"rigidi\" delle istruzioni a uso generale.\r\nCi impongono infatti dei modi specifici di organizzare dati e codice, perch\xe9 questi devono essere compatibili con il modo in cui l'algoritmo eseguito da un'istruzione \xe8 implementato in hardware."}),"\n",(0,r.jsx)(n.p,{children:"Nell'esercizio 1.1 abbiamo considerato due modi di scorrere i due array.\r\nNel primo, che \xe8 quello che abbiamo scelto, si carica l'indirizzo di inizio del vettore, e si usa un altro registro come indice, usando l'indirizzazione con indice.\r\nNel secondo, si usa un registro come puntatore alla cella corrente, inizializzato all'indirizzo di inizio del vettore e poi incrementato (della quantit\xe0 giusta) per passare all'elemento successivo.\r\nIn entrambi i casi, siamo liberi di usare i registri che vogliamo, per esempio non abbiamo nessun problema se scriviamo il programma di prima come segue:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"    lea msg_in, %eax\r\n    lea msg_out, %ebx\r\n    mov $0, %edx\r\nloop:   \r\n    movb (%eax, %edx), %cl\r\n    ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Infatti, usare ",(0,r.jsx)(n.code,{children:"esi"})," ed ",(0,r.jsx)(n.code,{children:"edi"})," come registri puntatori, ed ",(0,r.jsx)(n.code,{children:"ecx"})," come registro di indice, \xe8 del tutto opzionale."]}),"\n",(0,r.jsxs)(n.p,{children:["Tutto questo cambia quando si vogliono usare istruzioni specializzate come le istruzioni stringa.\r\nQueste ci impongono di usare ",(0,r.jsx)(n.code,{children:"esi"})," come puntatore al vettore sorgente, ",(0,r.jsx)(n.code,{children:"edi"})," come puntatore al vettore destinatario, ",(0,r.jsx)(n.code,{children:"eax"})," come registro dove scrivere o da cui leggere il valore da trasferire, ",(0,r.jsx)(n.code,{children:"ecx"})," come contatore delle ripetizioni da eseguire, etc.\r\nUna volta scelte le istruzioni da usare, dobbiamo quindi assicurarci di seguire quanto imposto dall'istruzione."]}),"\n",(0,r.jsxs)(n.p,{children:["Per questo esercizio siamo interessati alla ",(0,r.jsx)(n.code,{children:"lods"}),", che legge un valore dal vettore e ne sposta il puntatore allo step successivo, e la ",(0,r.jsx)(n.code,{children:"stos"}),", che scrive un valore nel vettore.\r\nPartiamo dal riscrivere il ",(0,r.jsx)(n.code,{children:"punto_2"})," dell'esercizio 1.1 in modo da rendere l'algoritmo compatibile."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"...\r\npunto_2:\r\n    lea msg_in, %esi\r\n    lea msg_out, %edi\r\nloop:\r\n// highlight-start\r\n    movb (%esi), %al\r\n    inc %esi\r\n// highlight-end\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n    and $0xdf, %al\r\npost_check:\r\n// highlight-start\r\n    movb %al, (%edi)\r\n    inc %edi\r\n// highlight-end\r\n    cmp $0x0d, %al\r\n    jne loop\r\n...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Abbiamo dunque rimosso l'uso di ",(0,r.jsx)(n.code,{children:"ecx"})," come indice, e usiamo ",(0,r.jsx)(n.code,{children:"esi"})," ed ",(0,r.jsx)(n.code,{children:"edi"})," come puntatori.\r\nIl fatto di usare la ",(0,r.jsx)(n.code,{children:"inc"})," \xe8 legato alla dimensione dei dati, cio\xe8 1 byte.\r\nDovremmo invece scrivere ",(0,r.jsx)(n.code,{children:"add $2, %esi"})," o ",(0,r.jsx)(n.code,{children:"add $4, %esi"})," per dati su 2 o 4 byte.\r\nAltra nota \xe8 che ",(0,r.jsx)(n.em,{children:"incrementiamo"})," i puntatori, anzich\xe9 decrementarli, perch\xe9 stiamo eseguendo l'operazione da sinistra verso destra."]}),"\n",(0,r.jsxs)(n.p,{children:["Siamo pronti adesso a sostituire le istruzioni evidenziate con delle istruzioni stringa.\r\nIl sorgente finale \xe8 scaricabile ",(0,r.jsx)(n.a,{href:"pathname:///2025-26/code/assembler/1/maiusc-str.s",children:"qui"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"...\r\npunto_2:\r\n    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    // highlight-start\r\n    cld\r\n    // highlight-end\r\nloop:\r\n// highlight-start\r\n    lodsb\r\n// highlight-end\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n    and $0xdf, %al\r\npost_check:\r\n// highlight-start\r\n    stosb\r\n// highlight-end\r\n    cmp $0x0d, %al\r\n    jne loop\r\n...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["L'istruzione ",(0,r.jsx)(n.code,{children:"cld"})," serve a impostare a 0 il flag di direzione, che serve a indicare alle istruzioni stringa se andare da sinistra verso destra o il contrario.\r\nDato che tutti i registri sono impliciti, dobbiamo sempre specificare la dimensione delle istruzioni, in questo caso ",(0,r.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Come esercizio, pu\xf2 essere interessante osservare con il debugger l'evoluzione dei registri, osservando come si eseguono pi\xf9 operazioni con una sola istruzione."}),"\n",(0,r.jsx)(n.h3,{id:"esercizio-16-esercizio-di-debugging-soluzione-passo-passo",children:"Esercizio 1.6: esercizio di debugging, soluzione passo-passo"}),"\n",(0,r.jsx)(n.p,{children:"Ricordiamo la traccia dell'esercizio:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Scrivere un programma che, a partire dalla sezione ",(0,r.jsx)(n.code,{children:".data"})," che segue (e scaricabile ",(0,r.jsx)(n.a,{href:"pathname:///2025-26/code/assembler/1/per-casa/conta_num.s",children:"qui"}),"), conta e stampa il numero di occorrenze di ",(0,r.jsx)(n.code,{children:"numero"})," in ",(0,r.jsx)(n.code,{children:"array"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\n'})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Questa \xe8 invece la soluzione proposta dall'esercizio:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\r\n\r\n.text\r\n\r\n_main:\r\n    nop\r\n    mov $0, %cl\r\n    mov numero, %ax\r\n    mov $0, %esi\r\n\r\ncomp: \r\n    cmp array_len, %esi\r\n    je fine\r\n    cmpw array(%esi), %ax\r\n    jne poi\r\n    inc %cl\r\n\r\npoi:  \r\n    inc %esi\r\n    jmp comp\r\n\r\nfine: \r\n    mov %cl, %al\r\n    call outdecimal_byte\r\n    ret\r\n\n'})}),"\n",(0,r.jsx)(n.p,{children:"Come prima cosa, cerchiamo di capire, a grandi linee, cosa cerca di fare questo programma."}),"\n",(0,r.jsxs)(n.p,{children:["Notiamo l'uso di ",(0,r.jsx)(n.code,{children:"%cl"}),": dall'inizializzazione a riga 12, l'incremento condizionato a righe 19-21, e la stampa a righe 28-29, si evince che ",(0,r.jsx)(n.code,{children:"%cl"})," \xe8 usato come contatore dei successi, ossia di quante volte \xe8 stato trovato ",(0,r.jsx)(n.code,{children:"numero"})," in ",(0,r.jsx)(n.code,{children:"array"}),".\r\nNotiamo che ",(0,r.jsx)(n.code,{children:"%ax"})," viene inizializzato con ",(0,r.jsx)(n.code,{children:"numero"})," e, prima della stampa, mai aggiornato.\r\nInfine, ",(0,r.jsx)(n.code,{children:"%esi"})," viene inizializzato a 0 e incrementato a fine di ogni ciclo, confrontandolo con ",(0,r.jsx)(n.code,{children:"array_len"})," per determinare quando uscire dal loop.\r\nInfine, a riga 19 notiamo il confronto tra un valore di ",(0,r.jsx)(n.code,{children:"array"}),", indicizzato con ",(0,r.jsx)(n.code,{children:"%esi"}),", e ",(0,r.jsx)(n.code,{children:"%ax"}),", che contiene ",(0,r.jsx)(n.code,{children:"numero"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Si ricostruisce quindi questa logica: scorro valore per valore ",(0,r.jsx)(n.code,{children:"array"}),", indicizzandolo con ",(0,r.jsx)(n.code,{children:"%esi"}),", e lo confronto con ",(0,r.jsx)(n.code,{children:"numero"}),", che \xe8 appoggiato su ",(0,r.jsx)(n.code,{children:"%ax"})," (perch\xe9 il confronto tra due valori in memoria non \xe8 possibile con ",(0,r.jsx)(n.code,{children:"cmp"}),"). Utilizzo ",(0,r.jsx)(n.code,{children:"%cl"})," come contatore dei successi, e alla fine dello scorrimento ne stampo il valore."]}),"\n",(0,r.jsx)(n.p,{children:"Fin qui nessuna sorpresa, il programma sembra seguire lo schema che si seguirebbe con un normale programma in C:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-C",children:"int cl = 0;\r\nfor(int esi = 0; esi < array_len; esi++){\r\n    if(array[esi] == numero)\r\n        cl++;\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Proviamo ad eseguire il programma: ci si aspetta che stampi 2. Invece, stampa 3.\r\nDobbiamo passare al debugger."}),"\n",(0,r.jsxs)(n.p,{children:["Quello che ci conviene guardare \xe8 quello che succede ad ogni loop, in particolare alla riga 19, dove la ",(0,r.jsx)(n.code,{children:"cmpw"})," confronta un valore di ",(0,r.jsx)(n.code,{children:"array"})," con ",(0,r.jsx)(n.code,{children:"%ax"}),", che contiene ",(0,r.jsx)(n.code,{children:"numero"}),".\r\nPer\xf2, la ",(0,r.jsx)(n.code,{children:"cmpw"})," utilizza un indirizzamento complesso che, abbiamo visto, richiede una sintassi pi\xf9 complicata nel debugger.\r\nCambio quindi quella istruzione in una serie equivalente che sia pi\xf9 facile da osservare col debugger."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\r\n\r\n.text\r\n\r\n_main:\r\n    nop\r\n    mov $0, %cl\r\n    mov numero, %ax\r\n    mov $0, %esi\r\n\r\ncomp: \r\n    cmp array_len, %esi\r\n    je fine\r\n// highlight-start\r\n    movw array(%esi), %bx\r\n    cmpw %bx, %ax\r\n// highlight-end\r\n    jne poi\r\n    inc %cl\r\n\r\npoi:  \r\n    inc %esi\r\n    jmp comp\r\n\r\nfine: \r\n    mov %cl, %al\r\n    call outdecimal_byte\r\n    ret\r\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Assemblo, avvio il debugger, e setto un breakpoint alla riga 20 con ",(0,r.jsx)(n.code,{children:"break 20"}),".\r\nLascio girare il programma con ",(0,r.jsx)(n.code,{children:"continue"}),", che quasi immediatamente raggiunge la riga 20 e si ferma.\r\nRicordiamo che il debugger si ferma ",(0,r.jsx)(n.em,{children:"prima"})," di eseguire una istruzione."]}),"\n",(0,r.jsxs)(n.p,{children:["Vediamo lo stato dei registri, con ",(0,r.jsx)(n.code,{children:"i r ax bx cl esi"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(gdb) i r ax bx cl esi\r\nax             0x1                 1\r\nbx             0x1                 1\r\ncl             0x0                 0\r\nesi            0x0                 0\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Fin qui, tutto come ci si aspetta: ",(0,r.jsx)(n.code,{children:"%ax"})," che contiene ",(0,r.jsx)(n.code,{children:"numero"}),", ",(0,r.jsx)(n.code,{children:"%bx"})," contiene il numero alla prima cella di ",(0,r.jsx)(n.code,{children:"array"}),", i due contatori ",(0,r.jsx)(n.code,{children:"%cl"})," e ",(0,r.jsx)(n.code,{children:"%esi"})," sono a 0.\r\nFacciamo ",(0,r.jsx)(n.code,{children:"step"})," per vedere l'esito del confronto: dopo la riga 21 l'esecuzione giunge alla riga 22, indicando che il salto non \xe8 stato fatto perch\xe9 ",(0,r.jsx)(n.code,{children:"jne"})," \xe8 stata eseguita dopo un confronto tra valori uguali."]}),"\n",(0,r.jsxs)(n.p,{children:["Continuiamo con ",(0,r.jsx)(n.code,{children:"step"})," controllando che il comportamento sia quello atteso, fino a giungere di nuovo alla riga 20."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(gdb) i r ax bx cl esi\r\nax             0x1                 1\r\nbx             0x0                 0\r\ncl             0x1                 1\r\nesi            0x1                 1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Qui abbiamo la prima sorpresa. In ",(0,r.jsx)(n.code,{children:"%bx"})," troviamo 0, ma il secondo valore di ",(0,r.jsx)(n.code,{children:"array"})," \xe8 256.\r\nSe continuiamo, vediamo che 256 compare come terzo valore, poi 1 come quarto, poi 256 come quinto.\r\nAbbiamo quindi dei valori aggiuntivi che compaiono nel vettore mentre lo scorriamo ma non nell'allocazione codice a riga 4.\r\nContinuando ancora, vediamo che i 9 valori coperti dal programma non sono affatto tutti e 9 quelli a riga 4, e che effettivamente il valore 1 compare 3 volte."]}),"\n",(0,r.jsxs)(n.p,{children:["Abbiamo intanto confinato il problema: la ",(0,r.jsx)(n.em,{children:"lettura"})," di valori da ",(0,r.jsx)(n.code,{children:"array"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Per capire cosa sta succedendo, dobbiamo ricordare come si comporta l'allocazione in memoria di valori su pi\xf9 byte: abbiamo infatti a che fare con ",(0,r.jsx)(n.em,{children:"word"}),", composte da 2 byte ciascuna, e un indirizzo in memoria \xe8 l'indirizzo di un solo byte."]}),"\n",(0,r.jsxs)(n.p,{children:["L'architettura x86 \xe8 ",(0,r.jsx)(n.em,{children:"little-endian"}),", che significa ",(0,r.jsx)(n.strong,{children:"little end first"}),", ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Endianness",children:"un riferimento a I viaggi di Gulliver"}),".\r\nQuesto si traduce nel fatto che quando un valore di ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"n"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," byte viene salvato in memoria ",(0,r.jsx)(n.em,{children:"a partire"})," dall'indirizzo ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"a"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"})]})})]}),", il byte meno significativo del valore viene salvato in ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"a"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"})]})})]}),", il secondo meno significativo in ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mn,{children:"1"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a+1"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,r.jsx)(n.span,{className:"mord",children:"1"})]})]})]}),", e cos\xec via fino al pi\xf9 significativo in ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mo,{stretchy:"false",children:"("}),(0,r.jsx)(n.mi,{children:"n"}),(0,r.jsx)(n.mo,{children:"\u2212"}),(0,r.jsx)(n.mn,{children:"1"}),(0,r.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a+(n-1)"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mopen",children:"("}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mord",children:"1"}),(0,r.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Possiamo quindi immaginare cos\xec il nostro ",(0,r.jsx)(n.code,{children:"array"})," in memoria."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:(0,o.Ay)("/2025-26/img/assembler/2/layout-1.drawio.png"),style:{maxWidth:"min(100%, 30rem)"},alt:"\r\nLo schema mostra come i primi 3 valori (0x0001 = 1, 0x0100 = 256 e 0x0100 = 256) sono scritti in 6 byte consecutivi:\r\n0x01, 0x00, 0x00, 0x01, 0x00, 0x01.\r\nGli indirizzi di questi byte sono consecutivi: la prima coppia comincia ad 'array', la seconda ad 'array+2', la terza ad 'array+4'.\r\n"}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)(n.p,{children:["Layout di ",(0,r.jsx)(n.code,{children:"array"})," in memoria."]})})]}),"\n",(0,r.jsxs)(n.p,{children:["La lettura di una ",(0,r.jsx)(n.em,{children:"word"})," dalla memoria funziona quindi cos\xec: dato l'indirizzo ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"a"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"})]})})]}),", vengono letti i byte agli indirizzi ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"a"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"})]})})]})," e ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mn,{children:"1"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a+1"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,r.jsx)(n.span,{className:"mord",children:"1"})]})]})]})," e contatenati nell'ordine ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mo,{stretchy:"false",children:"("}),(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mn,{children:"1"}),(0,r.jsx)(n.mo,{separator:"true",children:","}),(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"(a+1, a)"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mopen",children:"("}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mord",children:"1"}),(0,r.jsx)(n.span,{className:"mpunct",children:","}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),".\r\nUna istruzione come ",(0,r.jsx)(n.code,{children:"movw a, %bx"}),", quindi, salver\xe0 il contenuto di ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mn,{children:"1"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a+1"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,r.jsx)(n.span,{className:"mord",children:"1"})]})]})]})," in ",(0,r.jsx)(n.code,{children:"%bh"})," e il contenuto di ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"a"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"})]})})]})," in ",(0,r.jsx)(n.code,{children:"%bl"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Per la lettura di pi\xf9 ",(0,r.jsx)(n.em,{children:"word"})," consecutive, dobbiamo assicurarci di incrementare l'indirizzo di 2 alla volta: come mostrato in figura, il secondo valore \xe8 memorizzato a partire da ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mi,{children:"r"}),(0,r.jsx)(n.mi,{children:"r"}),(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mi,{children:"y"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mn,{children:"2"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"array+2"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.1944em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"rr"}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,r.jsx)(n.span,{className:"mord",children:"2"})]})]})]}),", il terzo da ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mi,{children:"r"}),(0,r.jsx)(n.mi,{children:"r"}),(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mi,{children:"y"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mn,{children:"4"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"array+4"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.1944em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"rr"}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,r.jsx)(n.span,{className:"mord",children:"4"})]})]})]}),", e cos\xec via."]}),"\n",(0,r.jsx)(n.p,{children:"Tornando per\xf2 al codice dell'esercizio, questo non succede:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"comp: \r\n// highlight-start\r\n    cmp array_len, %esi\r\n// highlight-end\r\n    je fine\r\n// highlight-start\r\n    movw array(%esi), %bx\r\n// highlight-end\r\n    cmpw %bx, %ax\r\n    jne poi\r\n    inc %cl\r\n\r\npoi:  \r\n// highlight-start\r\n    inc %esi\r\n// highlight-end\r\n    jmp comp\r\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Ecco quindi spiegato cosa legge il programma in memoria: quando alla seconda iterazione si esegue ",(0,r.jsx)(n.code,{children:"movb array(%esi), %bx"}),", con ",(0,r.jsx)(n.code,{children:"%esi"})," che vale 1, si sta leggendo un valore composto dal byte meno significativo del secondo valore concatenato con il byte pi\xf9 significativo del primo.\r\nQuesto valore \xe8 del tutto estraneo e privo di senso se confrontato con ",(0,r.jsx)(n.code,{children:"array"})," cos\xec come \xe8 stato dichiarato e allocato, ma nell'eseguire le istruzioni il processore non controlla niente di tutto ci\xf2."]}),"\n",(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:(0,o.Ay)("/2025-26/img/assembler/2/layout-2.drawio.png"),style:{maxWidth:"min(100%, 30rem)"},alt:"\r\nStesso schema di prima, con delle letture errate evidenziate. \r\nLeggendo due byte a partire da 'array+1' troviamo {0x00, 0x00} = 0x0000 = 0; a partire da 'array+3' troviamo {0x01, 0x00} = 0x0001 = 1.\r\nEntrambi i valori non fanno parte dell'array dichiarato.\r\n"}),(0,r.jsx)("figcaption",{children:(0,r.jsxs)(n.p,{children:["Lettura erronea di ",(0,r.jsx)(n.code,{children:"array"}),": sbagliando l'incremento dell'indirizzo, leggiamo dei byte senza alcuna relazione fra loro dalla memoria e li interpretiamo come parti di una word."]})})]}),"\n",(0,r.jsxs)(n.p,{children:["Abbiamo due strade per correggere questo errore.\r\nIl primo approccio \xe8 quello di incrementare ",(0,r.jsx)(n.code,{children:"%esi"})," di 2 alla volta, cos\xec che l'indirizzamente ",(0,r.jsx)(n.code,{children:"array(%esi)"})," risulti corretto.\r\nQuesto per\xf2 vuol dire che ",(0,r.jsx)(n.code,{children:"%esi"})," non pu\xf2 pi\xf9 essere usato come contatore confrontabile con ",(0,r.jsx)(n.code,{children:"array_len"}),", e si dovr\xe0 gestire tale confronto in altro modo (per esempio, usando un registro separato come contatore).\r\nLa seconda strada \xe8 quella di usare il fattore di ",(0,r.jsx)(n.em,{children:"scala"})," dell'indirizzamento, che \xe8 pensato proprio per questi casi.\r\nInfatti, ",(0,r.jsx)(n.code,{children:"array(, %esi, 2)"})," calcoler\xe0 l'indirizzo ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mi,{children:"r"}),(0,r.jsx)(n.mi,{children:"r"}),(0,r.jsx)(n.mi,{children:"a"}),(0,r.jsx)(n.mi,{children:"y"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mn,{children:"2"}),(0,r.jsx)(n.mo,{children:"\u2217"}),(0,r.jsx)(n.mi,{children:"e"}),(0,r.jsx)(n.mi,{children:"s"}),(0,r.jsx)(n.mi,{children:"i"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"array + 2 * esi"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.1944em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"rr"}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,r.jsx)(n.span,{className:"mord",children:"2"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"es"}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})]})]}),".\r\nDa notare la virgola subito dopo la parentesi, a indicare che non si sta specificando alcun registro ",(0,r.jsx)(n.em,{children:"base"}),", mentre ",(0,r.jsx)(n.code,{children:"%esi"})," \xe8 ",(0,r.jsx)(n.em,{children:"indice"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In ultimo, una riflessione sul codice C che abbiamo visto prima come modello di questo programma: in quel codice non vi \xe8 alcun errore perch\xe9 ",(0,r.jsx)(n.code,{children:"array[esi]"}),", sfruttando la tipizzazione e l'aritmetica dei puntatori, applica sempre i fattori di scala corretti."]}),"\n",(0,r.jsxs)(n.p,{children:["Il codice finale, scaricabile ",(0,r.jsx)(n.a,{href:"pathname:///2025-26/code/assembler/2/conta_num_debug_sol.s",children:"qui"}),", \xe8 il seguente:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\r\n\r\n.text\r\n\r\n_main:\r\n    nop\r\n    mov $0, %cl\r\n    mov numero, %ax\r\n    mov $0, %esi\r\n\r\ncomp: \r\n    cmp array_len, %esi\r\n    je fine\r\n// highlight-start\r\n    cmpw array(, %esi, 2), %ax\r\n// highlight-end\r\n    jne poi\r\n    inc %cl\r\n\r\npoi:  \r\n    inc %esi\r\n    jmp comp\r\n\r\nfine: \r\n    mov %cl, %al\r\n    call outdecimal_byte\r\n    ret\r\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"esercizio-18-soluzione-passo-passo",children:"Esercizio 1.8: soluzione passo-passo"}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsx)(n.p,{children:"TODO: QUESTO E' STATO SPOSTATO"})}),"\n",(0,r.jsx)(n.p,{children:"Ricordiamo la traccia dell'esercizio:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Scrivere un programma che svolge quanto segue."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# leggere 2 numeri interi in base 10, calcolarne il prodotto, e stampare il risultato.\r\n\r\n# lettura:\r\n# come primo carattere leggere il segno del numero, cio\xe8 un '+' o un '-'\r\n# segue il modulo del numero, minore di 256\r\n\r\n# stampa:\r\n# stampare prima il segno del numero (+ o -), poi il modulo in cifre decimali\n"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Questa \xe8 invece la soluzione proposta dall'esercizio:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:".include \"./files/utility.s\"\r\n\r\nmess1:  .asciz \"inserire il primo numero intero:\\r\" \r\nmess2:  .asciz \"inserire il secondo numero intero:\\r\"\r\nmess3:  .asciz \"il prodotto dei due numeri e':\\r\"\r\na:      .word 0\r\nb:      .word 0\r\n\r\n_main:\r\n    nop\r\n    lea mess1, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, a\r\n\r\n    lea mess2, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, b\r\n\r\n    mov a, %ax\r\n    mov b, %bx\r\n    imul %bx\r\n\r\n    lea mess3, %ebx\r\n    call outline\r\n    call out_intero\r\n    ret\r\n\r\n# legge un intero composto da segno e modulo minore di 256\r\n# ne lascia la rappresentazione in complemento alla radice base 2 in ax\r\nin_intero:\r\n    push %ebx\r\n    mov $0, %bl\r\nin_segno_loop:   \r\n    call inchar\r\n    cmp $'+', %al\r\n    je in_segno_poi\r\n    cmp $'-', %al\r\n    jne in_segno_loop\r\n    mov $1, %bl\r\nin_segno_poi:\r\n    call outchar\r\n    call indecimal_word\r\n    call newline\r\n    cmp $1, %bl\r\n    jne in_intero_fine\r\n    neg %ax\r\nin_intero_fine:\r\n    pop %ebx\r\n    ret\r\n\r\n# legge la rappresentazione di un numero intero in complemento alla radice base 2 in eax\r\n# lo stampa come segno seguito dalle cifre decimali\r\nout_intero:\r\n    push %ebx\r\n    mov %eax, %ebx\r\n    cmp $0, %ebx\r\n    ja out_intero_pos\r\n    jmp out_intero_neg\r\nout_intero_pos:\r\n    mov $'+', %al\r\n    call outchar\r\n    jmp out_intero_poi\r\nout_intero_neg:\r\n    mov $'-', %al\r\n    call outchar\r\n    neg %ebx\r\n    jmp out_intero_poi\r\nout_intero_poi:\r\n    mov %ebx, %eax\r\n    call outdecimal_long\r\n    pop %ebx\r\n    ret\n"})}),"\n",(0,r.jsx)(n.p,{children:"Per brevit\xe0, e vista la documentazione dei sottoprogrammi, lascio al lettore l'interpretazione a grandi linee del programma.\r\nPasseremo direttamente ai problemi incontrati testando il programma."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"inserire il primo numero intero:\r\n+30\r\nSegmentation fault\n"})}),"\n",(0,r.jsxs)(n.p,{children:["L'errore, sicuramente gi\xe0 ben noto, \xe8 in realt\xe0\tun risultato tipico di una ",(0,r.jsx)(n.em,{children:"vasta"}),' gamma di errori.\r\nDi per s\xe9 significa semplicemente "tentativo di accesso in una zona di memoria a cui non si pu\xf2 accedere per fare quello che si voleva fare".\r\nNon spiega, per esempio, cos\'\xe8 che si voleva fare e perch\xe9 \xe8 sbagliato.']}),"\n",(0,r.jsx)(n.p,{children:"Vediamo tramite il debugger."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Program received signal SIGSEGV, Segmentation fault.\r\n    _main () at /mnt/c/reti_logiche/assembler/lezioni/2/imul_debug.s:14\r\n14          mov %ax, a\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Vediamo che il problema \xe8 il tentativo di scrivere all'indirizzo ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"a"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"a"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"a"})]})})]}),", che \xe8 la word allocata poco pi\xf9 su.\r\nIl problema qui \xe8 che il programma non ha nessuna distinzione tra ",(0,r.jsx)(n.code,{children:".data"})," e ",(0,r.jsx)(n.code,{children:".text"}),": di default \xe8 tutto ",(0,r.jsx)(n.code,{children:".text"}),", dove non si pu\xf2 scrivere perch\xe9 non ci \xe8 permesso, normalmente, di sovrascrivere le istruzioni del programma."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n// highlight-start\r\n.data\r\n// highlight-end\r\nmess1:  .asciz "inserire il primo numero intero:\\r" \r\nmess2:  .asciz "inserire il secondo numero intero:\\r"\r\nmess3:  .asciz "il prodotto dei due numeri e\':\\r"\r\na:      .word 0\r\nb:      .word 0\r\n\r\n// highlight-start\r\n.text\r\n// highlight-end\r\n_main:\r\n...\n'})}),"\n",(0,r.jsx)(n.p,{children:"Riproviamo il programma:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"inserire il primo numero intero:\r\n+30\r\ninserire il secondo numero intero:\r\n+20\r\nil prodotto dei due numeri e':\r\n+600\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Fin qui, sembra andare bene.\r\nRicordiamoci per\xf2 di testare ",(0,r.jsx)(n.em,{children:"tutti i casi di interesse"}),", in particolare i ",(0,r.jsx)(n.em,{children:"casi limite"}),".\r\nLe specifiche dell'esercizio ci chiedono di considerare numeri interi di modulo inferiore a 256."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"inserire il primo numero intero:\r\n+255\r\ninserire il secondo numero intero:\r\n+255\r\nil prodotto dei due numeri e':\r\n+65025\n"})}),"\n",(0,r.jsx)(n.p,{children:"Corretto."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"inserire il primo numero intero:\r\n-255\r\ninserire il secondo numero intero:\r\n+255\r\nil prodotto dei due numeri e':\r\n+511\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Decisamente non corretto.\r\nVerifichiamo col debugger.\r\nPer prima cosa, ci assicuriamo che la lettura di numeri negativi sia corretta.\r\nMettiamo un brekpoint a riga 16 (riga 14 prima dell'aggiunta di ",(0,r.jsx)(n.code,{children:".data"})," e ",(0,r.jsx)(n.code,{children:".text"}),"), e verifichiamo cosa viene letto quando inseriamo ",(0,r.jsx)(n.code,{children:"-255"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(gdb) b 16\r\nBreakpoint 2 at 0x56556774: file /mnt/c/reti_logiche/assembler/lezioni/2/imul_debug.s, line 16.\r\n(gdb) c\r\nContinuing.\r\ninserire il primo numero intero:\r\n-255\r\n\r\nBreakpoint 2, _main () at /mnt/c/reti_logiche/assembler/lezioni/2/imul_debug.s:16\r\n16          mov %ax, a\r\n(gdb) i r ax\r\nax             0xff01              -255\r\n(gdb)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Fin qui \xe8 bene, il problema non sembra essere nella lettura di interi da tastiera.\r\nProseguiamo quindi alla moltiplicazione, e controlliamone il risultato.\r\nLa ",(0,r.jsx)(n.code,{children:"imul"})," utilizzata \xe8 a 16 bit, che da documentazione vediamo usa ",(0,r.jsx)(n.code,{children:"%ax"})," come operando implicito, ",(0,r.jsx)(n.code,{children:"%bx"})," come operando esplicito, e ",(0,r.jsx)(n.code,{children:"%dx_%ax"})," come destinatario del calcolo."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Breakpoint 3, _main () at /mnt/c/reti_logiche/assembler/lezioni/2/imul_debug.s:25\r\n25          imul %bx\r\n(gdb) i r ax bx\r\nax             0xff01              -255\r\nbx             0xff                255\r\n(gdb) s\r\n27          lea mess3, %ebx\r\n(gdb) i r dx ax\r\ndx             0xffff              -1\r\nax             0x1ff               511\r\n(gdb)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Concatenando i due registri otteniamo ",(0,r.jsx)(n.code,{children:"0xffff01ff"}),", ricordando, in particolare per ",(0,r.jsx)(n.code,{children:"%ax"}),", che ",(0,r.jsx)(n.code,{children:"gdb"})," omette nelle stampe gli zeri all'inizio di esadecimali.\r\nPossiamo verificare questo valore convertendo da esadecimale a decimale con una calcolatrice da programmatore: quella di Windows richiede prima di estendere il valore su 32 bit, cio\xe8 ",(0,r.jsx)(n.code,{children:"0xffffffffffff01ff"})," (ogni carattere esadecimale sono 4 bit e gli interi si estendono ripetendo il bit pi\xf9 significativo, vanno quindi aggiunte 8 ",(0,r.jsx)(n.code,{children:"f"}),"), altre calcolatrici permettono di specificare il numero di bit.\r\nIl risultato \xe8 -65025, che \xe8 quello che ci aspettiamo.\r\nAnche qui quindi \xe8 bene: resta la stampa di questo valore, cio\xe8 il sottoprogramma ",(0,r.jsx)(n.code,{children:"out_intero"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"# legge la rappresentazione di un numero intero in complemento alla radice base 2 in eax\r\n# lo stampa come segno seguito dalle cifre decimali\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Vediamo qui la prima discrepanza: il sottoprogramma si aspetta il risultato in ",(0,r.jsx)(n.code,{children:"%eax"}),", ma noi sappiamo che la ",(0,r.jsx)(n.code,{children:"imul"})," lo lascia in ",(0,r.jsx)(n.code,{children:"%dx_%ax"}),".\r\nCi si pu\xf2 chiedere quale dei due correggere, se il sottoprogramma o il programma che lo usa:\r\nin generale, si cambiano le specifiche di un componente interno (il sottoprogramma) solo quando ",(0,r.jsx)(n.em,{children:"non hanno senso"}),", mentre in questo caso abbiamo il componente esterno (il programma) che non rispetta le specifiche d'uso di quello interno."]}),"\n",(0,r.jsxs)(n.p,{children:["Assicuriamoci quindi di lasciare il risultato nel registro giusto prima di ",(0,r.jsx)(n.code,{children:"call out_intero"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"...\r\n    mov a, %ax\r\n    mov b, %bx\r\n    imul %bx\r\n\r\n// highlight-start\r\n    shl $16, %edx\r\n    movw %ax, %dx\r\n    movl %edx, %eax\r\n// highlight-end\r\n\r\n    lea mess3, %ebx\r\n    call outline\r\n    call out_intero\r\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Riproviamo ad eseguire:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"inserire il primo numero intero:\r\n-255\r\ninserire il secondo numero intero:\r\n+255\r\nil prodotto dei due numeri e':\r\n+4294902271\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Ritorniamo al debugger, cominciando dalla ",(0,r.jsx)(n.code,{children:"call"})," di ",(0,r.jsx)(n.code,{children:"out_intero"}),", verificando di avere il valore corretto in ",(0,r.jsx)(n.code,{children:"%eax"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Breakpoint 2, _main () at /mnt/c/reti_logiche/assembler/lezioni/2/imul_debug.s:33\r\n33          call out_intero\r\n(gdb) i r eax\r\neax            0xffff01ff          -65025\r\n(gdb) \n"})}),"\n",(0,r.jsxs)(n.p,{children:["Il valore \xe8 corretto. Proseguiamo quindi nel sottoprogramma, cercando di capire come funziona e dove potrebbe sbagliare.\r\nLa prima cosa che notiamo \xe8 che il sottoprogramma ha due rami, ",(0,r.jsx)(n.code,{children:"out_intero_pos"})," e ",(0,r.jsx)(n.code,{children:"out_intero_neg"}),", dove stampa segni diversi e, in caso di numero negativo, usa la ",(0,r.jsx)(n.code,{children:"neg"})," per ottenere l'opposto.\r\nQuando si giunge a ",(0,r.jsx)(n.code,{children:"out_intero_poi"}),", stampa il modulo del numero usando ",(0,r.jsx)(n.code,{children:"outdecimal_long"})," (che, ricordiamo, supporta solo numeri naturali).\r\nTuttavia, nella nostra esecuzione abbiamo un negativo che viene stampato come naturale."]}),"\n",(0,r.jsxs)(n.p,{children:["Verifichiamo seguendo l'esecuzione con ",(0,r.jsx)(n.code,{children:"step"}),", che entra nel sottoprogramma ",(0,r.jsx)(n.code,{children:"out_intero"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(gdb) s\r\nout_intero () at /mnt/c/reti_logiche/assembler/lezioni/2/imul_debug.s:62\r\n62          push %ebx\r\n(gdb) s\r\n63          mov %eax, %ebx\r\n(gdb) s\r\n64          cmp $0, %ebx\r\n(gdb) i r ebx\r\nebx            0xffff01ff          -65025\r\n(gdb) s\r\n65          ja out_intero_pos\r\n(gdb) s\r\nout_intero_pos () at /mnt/c/reti_logiche/assembler/lezioni/2/imul_debug.s:68\r\n68          mov $'+', %al\r\n(gdb) \n"})}),"\n",(0,r.jsxs)(n.p,{children:["Effettivamente, nonostante ",(0,r.jsx)(n.code,{children:"%ebx"})," sia un numero negativo, il salto a ",(0,r.jsx)(n.code,{children:"out_intero_pos"})," viene eseguito.\r\nGuardiamo per\xf2 meglio: l'istruzione di salto \xe8 ",(0,r.jsx)(n.code,{children:"ja"}),", che interpreta il confronto come ",(0,r.jsx)(n.em,{children:"tra numeri naturali"}),".\r\nIn effetti, qualunque valore di ",(0,r.jsx)(n.code,{children:"%ebx"})," diverso da 0, se interpretato come naturale, risulta maggiore di 0.\r\nCorreggiamo quindi utilizzando ",(0,r.jsx)(n.code,{children:"jg"}),", e ritestiamo."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"    cmp $0, %ebx\r\n// highlight-start\r\n    jg out_intero_pos\r\n// highlight-end\r\n    jmp out_intero_neg\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"inserire il primo numero intero:\r\n-255\r\ninserire il secondo numero intero:\r\n+255\r\nil prodotto dei due numeri e':\r\n-65025\n"})}),"\n",(0,r.jsx)(n.p,{children:"Si dovrebbe continuare con altri test (combinazioni di segni, uso di 0) fino a convincersi che funzioni, per questa lezione ci fermiamo qui."}),"\n",(0,r.jsxs)(n.p,{children:["Il codice finale, scaricabile ",(0,r.jsx)(n.a,{href:"pathname:///2025-26/code/assembler/2/imul_debug_sol.s",children:"qui"}),", \xe8 il seguente:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:".include \"./files/utility.s\"\r\n\r\n.data\r\nmess1:  .asciz \"inserire il primo numero intero:\\r\" \r\nmess2:  .asciz \"inserire il secondo numero intero:\\r\"\r\nmess3:  .asciz \"il prodotto dei due numeri e':\\r\"\r\na:      .word 0\r\nb:      .word 0\r\n\r\n.text\r\n_main:      \r\n    nop\r\n    lea mess1, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, a\r\n\r\n    lea mess2, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, b\r\n\r\n    mov a, %ax\r\n    mov b, %bx\r\n    imul %bx\r\n\r\n    shl $16, %edx\r\n    movw %ax, %dx\r\n    movl %edx, %eax\r\n\r\n    lea mess3, %ebx\r\n    call outline\r\n    call out_intero\r\n    ret\r\n\r\n# legge un intero composto da segno e modulo minore di 256\r\n# ne lascia la rappresentazione in complemento alla radice base 2 in ax\r\nin_intero:\r\n    push %ebx\r\n    mov $0, %bl\r\nin_segno_loop:   \r\n    call inchar\r\n    cmp $'+', %al\r\n    je in_segno_poi\r\n    cmp $'-', %al\r\n    jne in_segno_loop\r\n    mov $1, %bl\r\nin_segno_poi:\r\n    call outchar\r\n    call indecimal_word\r\n    call newline\r\n    cmp $1, %bl\r\n    jne in_intero_fine\r\n    neg %ax\r\nin_intero_fine:\r\n    pop %ebx\r\n    ret\r\n\r\n# legge la rappresentazione di un numero intero in complemento alla radice base 2 in eax\r\n# lo stampa come segno seguito dalle cifre decimali\r\nout_intero:\r\n    push %ebx\r\n    mov %eax, %ebx\r\n    cmp $0, %ebx\r\n    jg out_intero_pos\r\n    jmp out_intero_neg\r\nout_intero_pos:\r\n    mov $'+', %al\r\n    call outchar\r\n    jmp out_intero_poi\r\nout_intero_neg:\r\n    mov $'-', %al\r\n    call outchar\r\n    neg %ebx\r\n    jmp out_intero_poi\r\nout_intero_poi:\r\n    mov %ebx, %eax\r\n    call outdecimal_long\r\n    pop %ebx\r\n    ret\r\n\n"})}),"\n",(0,r.jsx)(n.h2,{id:"esercizio-21-esercizio-desame-2022-01-26",children:"Esercizio 2.1: esercizio d'esame 2022-01-26"}),"\n",(0,r.jsxs)(n.p,{children:["Vediamo ora un esercizio d'esame, del 26 Gennaio 2022. Il testo con soluzione si trova ",(0,r.jsx)(n.a,{href:"http://docenti.ing.unipi.it/~a080368/Teaching/RetiLogiche/pdf/Esami/220126/220126_1.zip",children:"qui"}),"."]}),"\n",(0,r.jsx)(n.admonition,{title:"Provare da s\xe9",type:"tip",children:(0,r.jsx)(n.p,{children:"Provare a svolgere da s\xe9 l'esercizio, prima di guardare la soluzione o andare oltre per la discussione."})}),"\n",(0,r.jsx)(n.p,{children:"La soluzione di questo esercizio ha alcuni spunti interessanti."}),"\n",(0,r.jsxs)(n.p,{children:["Il primo \xe8 che il set di dati \xe8 presentato come una matrice.\r\nMa a differenza del C dove possiamo scrivere ",(0,r.jsx)(n.code,{children:"matrice[i][j]"})," e lasciare che l'aritmetica dei puntatori faccia il resto, in assember dobbiamo gestire da noi la rappresentazione di una matrice tramite un vettore, associando indici su due dimensioni a un solo indice.\r\nL'esercizio ci aiuta in questo indicando una associazione specifica, usata anche per il caricamento dello stato iniziale."]}),"\n",(0,r.jsxs)(n.p,{children:["Da questa associazione osserviamo che: ogni lettera corrisponde a 4 celle consecutive, dove ",(0,r.jsx)(n.code,{children:"a"})," corrisponde a ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mo,{stretchy:"false",children:"["}),(0,r.jsx)(n.mn,{children:"0"}),(0,r.jsx)(n.mo,{separator:"true",children:","}),(0,r.jsx)(n.mn,{children:"3"}),(0,r.jsx)(n.mo,{stretchy:"false",children:"]"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"[0, 3]"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mopen",children:"["}),(0,r.jsx)(n.span,{className:"mord",children:"0"}),(0,r.jsx)(n.span,{className:"mpunct",children:","}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.jsx)(n.span,{className:"mord",children:"3"}),(0,r.jsx)(n.span,{className:"mclose",children:"]"})]})})]}),", ",(0,r.jsx)(n.code,{children:"b"})," a ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mo,{stretchy:"false",children:"["}),(0,r.jsx)(n.mn,{children:"4"}),(0,r.jsx)(n.mo,{separator:"true",children:","}),(0,r.jsx)(n.mn,{children:"7"}),(0,r.jsx)(n.mo,{stretchy:"false",children:"]"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"[4, 7]"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mopen",children:"["}),(0,r.jsx)(n.span,{className:"mord",children:"4"}),(0,r.jsx)(n.span,{className:"mpunct",children:","}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.jsx)(n.span,{className:"mord",children:"7"}),(0,r.jsx)(n.span,{className:"mclose",children:"]"})]})})]})," e cos\xec via.\r\nDate le 4 celle consecutive, il numero determina una tra queste, dove ",(0,r.jsx)(n.code,{children:"1"})," significa la prima, ",(0,r.jsx)(n.code,{children:"2"})," la seconda e cos\xec via.\r\nSe traduciamo la lettera in un indice ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"i"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})})]})," e il numero in un indice ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{children:"j"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"j"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.854em",verticalAlign:"-0.1944em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05724em"},children:"j"})]})})]}),", entrambi ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mo,{children:"\u2208"}),(0,r.jsx)(n.mo,{stretchy:"false",children:"["}),(0,r.jsx)(n.mn,{children:"0"}),(0,r.jsx)(n.mo,{separator:"true",children:","}),(0,r.jsx)(n.mn,{children:"3"}),(0,r.jsx)(n.mo,{stretchy:"false",children:"]"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\in [0, 3]"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.5782em",verticalAlign:"-0.0391em"}}),(0,r.jsx)(n.span,{className:"mrel",children:"\u2208"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mopen",children:"["}),(0,r.jsx)(n.span,{className:"mord",children:"0"}),(0,r.jsx)(n.span,{className:"mpunct",children:","}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.jsx)(n.span,{className:"mord",children:"3"}),(0,r.jsx)(n.span,{className:"mclose",children:"]"})]})]})]}),", possiamo esprimere quindi l'indice della cella nel vettore come ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mi,{children:"i"}),(0,r.jsx)(n.mo,{children:"\u2217"}),(0,r.jsx)(n.mn,{children:"4"}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mi,{children:"j"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"i*4 + j"})]})})}),(0,r.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,r.jsx)(n.span,{className:"mord",children:"4"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,r.jsx)(n.span,{className:"mbin",children:"+"}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.854em",verticalAlign:"-0.1944em"}}),(0,r.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05724em"},children:"j"})]})]})]}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Nella soluzione, i sottoprogrammi ",(0,r.jsx)(n.code,{children:"in_lettera"})," e ",(0,r.jsx)(n.code,{children:"in_numero"})," si occupano di leggere i due valori da tastiera (con la solita struttura ciclica per ignorare caratteri inattesi) e lasciare il relativo indice in ",(0,r.jsx)(n.code,{children:"%al"}),".\r\nDato che i caratteri utilizzati sono consecutivi nella tabella ASCII, questi indici sono calcolabili con una semplice sottrazione."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"# Sottoprogramma per la lettura della lettera, da 'a' a 'd'\r\n# Lascia l'indice corrispondente (da 0 a 3) in AL\r\nin_lettera:\r\n    call inchar\r\n    cmp $'a', %al\r\n    jb in_lettera\r\n    cmp $'d', %al\r\n    ja in_lettera\r\n    call outchar\r\n    sub $'a', %al\r\n    ret\n"})}),"\n",(0,r.jsx)(n.p,{children:"Questi indici sono poi composti secondo la formula di cui sopra."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"    call in_lettera\r\n    mov %al, %cl\r\n    shl $2, %cl # cl = cl * 4, ossia la dimensione di ogni riga\r\n    call in_numero\r\n    add %al, %cl # cl contiene l'indice (da 0 a 15) della posizione bersagliata\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Il secondo punto interessante \xe8 che non \xe8 necessario utilizzare un vettori di byte in memoria, perch\xe9 per gestire un flag vero/falso basta un bit, e per gestirne 16 basta una word.\r\nTuttavia, non abbiamo modo di interagire con i registri in modo diretto sul singolo bit: possiamo immaginare una sintassi come ",(0,r.jsx)(n.code,{children:"%ax[%cl]"})," che testi o modifichi uno specifico bit, ma il processore non ha nulla del genere."]}),"\n",(0,r.jsxs)(n.p,{children:["Possiamo per\xf2 utilizzare istruzioni bit a bit, con delle ",(0,r.jsx)(n.em,{children:"maschere"})," adeguate che vadano a testare o modificare solo ci\xf2 che ci interessa."]}),"\n",(0,r.jsxs)(n.p,{children:["Per il test, possiamo usare una ",(0,r.jsx)(n.code,{children:"and"})," con una maschera composta da soli 0 tranne che per la posizione che ci interessa testare.\r\nSe il risultato \xe8 diverso da 0, vuol dire che l'altro operando, alla posizione d'interesse, ha il bit 1."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"    mov $1, %ax\r\n    shl %cl, %ax # ax contiene una maschera da 16 bit con 1 nella posizione bersagliata\r\n    and %dx, %ax # se abbiamo colpito qualcosa, ax rimane invariato. altrimenti varra' 0\r\n    jz mancato\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Similmente, quando intendiamo mettere un bit a 0 (in questo caso, a indicare che il bersaglio colpito non c'\xe8 pi\xf9), possiamo usare una ",(0,r.jsx)(n.code,{children:"and"})," con maschera opposta alla precedente, ossia con soli 1 tranne che per la posizione da azzerare, o una ",(0,r.jsx)(n.code,{children:"xor"})," con la stessa maschera precedente, che causer\xe0 il cambio di valore (da 1 a 0 o da 0 a 1) solo del bit d'interesse.\r\nLa soluzione, dato che a questo punto \xe8 gi\xe0 noto che il bit di interesse \xe8 a 1, utilizza la seconda opzione."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",children:"colpito:\r\n    lea msg_colpito, %ebx\r\n    call outline\r\n    xor %ax, %dx # togliamo il bersaglio colpito\r\n    jmp ciclo_partita_fine\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Questo schema rende tra l'altro molto pi\xf9 semplice la lettura dello stato iniziale, dato che tutto il necessario \xe8 fatto dal sottoprogramma di utility ",(0,r.jsx)(n.code,{children:"inword"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"esercizi-per-casa",children:"Esercizi per casa"}),"\n",(0,r.jsx)(n.h3,{id:"esercizio-17",children:"Esercizio 1.7"}),"\n",(0,r.jsx)(n.p,{children:"Scrivere un programma che svolge quanto segue."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# leggere 2 numeri interi in base 10, calcolarne il prodotto, e stampare il risultato.\r\n\r\n# lettura:\r\n# come primo carattere leggere il segno del numero, cio\xe8 un '+' o un '-'\r\n# segue il modulo del numero, minore di 256\r\n\r\n# stampa:\r\n# stampare prima il segno del numero (+ o -), poi il modulo in cifre decimali\n"})}),"\n",(0,r.jsx)(n.h3,{id:"esercizio-18",children:"Esercizio 1.8"}),"\n",(0,r.jsxs)(n.p,{children:["Quello che segue (e scaricabile ",(0,r.jsx)(n.a,{href:"pathname:///2025-26/code/assembler/1/per-casa/imul_debug.s",children:"qui"}),") \xe8 un tentativo di soluzione dell'esercizio precedente.\r\nContiene tuttavia uno o pi\xf9 bug. Trovarli e correggerli."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:".include \"./files/utility.s\"\r\n\r\nmess1:  .asciz \"inserire il primo numero intero:\\r\" \r\nmess2:  .asciz \"inserire il secondo numero intero:\\r\"\r\nmess3:  .asciz \"il prodotto dei due numeri e':\\r\"\r\na:      .word 0\r\nb:      .word 0\r\n\r\n_main:      \r\n    nop\r\n    lea mess1, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, a\r\n\r\n    lea mess2, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, b\r\n\r\n    mov a, %ax\r\n    mov b, %bx\r\n    imul %bx\r\n\r\n    lea mess3, %ebx\r\n    call outline\r\n    call out_intero\r\n    ret\r\n\r\n# legge un intero composto da segno e modulo minore di 256\r\n# ne lascia la rappresentazione in complemento alla radice base 2 in ax\r\nin_intero:\r\n    push %ebx\r\n    mov $0, %bl\r\nin_segno_loop:   \r\n    call inchar\r\n    cmp $'+', %al\r\n    je in_segno_poi\r\n    cmp $'-', %al\r\n    jne in_segno_loop\r\n    mov $1, %bl\r\nin_segno_poi:\r\n    call outchar\r\n    call indecimal_word\r\n    call newline\r\n    cmp $1, %bl\r\n    jne in_intero_fine\r\n    neg %ax\r\nin_intero_fine:\r\n    pop %ebx\r\n    ret\r\n\r\n# legge la rappresentazione di un numero intero in complemento alla radice base 2 in eax\r\n# lo stampa come segno seguito dalle cifre decimali\r\nout_intero:\r\n    push %ebx\r\n    mov %eax, %ebx\r\n    cmp $0, %ebx\r\n    ja out_intero_pos\r\n    jmp out_intero_neg\r\nout_intero_pos:\r\n    mov $'+', %al\r\n    call outchar\r\n    jmp out_intero_poi\r\nout_intero_neg:\r\n    mov $'-', %al\r\n    call outchar\r\n    neg %ebx\r\n    jmp out_intero_poi\r\nout_intero_poi:\r\n    mov %ebx, %eax\r\n    call outdecimal_long\r\n    pop %ebx\r\n    ret\n"})}),"\n",(0,r.jsx)(n.h3,{id:"esercizio-22",children:"Esercizio 2.2"}),"\n",(0,r.jsxs)(n.p,{children:["Quello che segue (e scaricabile  ",(0,r.jsx)(n.a,{href:"pathname:///2025-26/code/assembler/2/per-casa/substr_debug.s",children:"qui"}),") \xe8 un tentativo di soluzione per le seguenti specifiche:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# Leggere una riga dal terminale, che DEVE contenere almeno 2 caratteri '_'\r\n# Identificare e stampa la sottostringa delimitata dai primi due caratteri '_'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Un esempio di output (",(0,r.jsx)(n.a,{href:"pathname:///2025-26/code/assembler/2/per-casa/esempio.txt",children:"qui"})," in formato txt) \xe8 il seguente"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"questa e' una _prova_ !!\r\nprova\n"})}),"\n",(0,r.jsx)(n.p,{children:"Contiene tuttavia uno o pi\xf9 bug. Trovarli e correggerli."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-assembler",metastring:"showLineNumbers",children:".include \"./files/utility.s\"\r\n\r\n.data\r\n\r\nmsg_in: .fill 80, 1, 0\r\n\r\n.text\r\n_main:  \r\n    nop\r\n    mov $80, %cx\r\n    lea msg_in, %ebx\r\n    call inline\r\n\r\n    cld\r\n    mov $'_', %al\r\n    lea msg_in, %esi\r\n    mov $80, %cx\r\n\r\n    repne scasb\r\n    mov %esi, %ebx\r\n    repne scasb\r\n    mov %esi, %ecx\r\n    sub %ebx, %ecx\r\n    call outline\r\n\r\n    ret\r\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"esercizio-23",children:"Esercizio 2.3"}),"\n",(0,r.jsx)(n.p,{children:"A partire dalla soluzione dell'esercizio precedente, estendere il programma per rispettare le seguenti specifiche:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# Leggere una riga dal terminale\r\n# Identificare e stampa la sottostringa delimitata dai primi due caratteri '_'\r\n# Se un solo carattere '_' e' presente, assumere che la sottostringa cominci \r\n# ad inizio stringa e finisca prima del carattere '_'\r\n# Se nessun carattere '_' e' presente, stampare l'intera stringa\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var a=i(96540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);