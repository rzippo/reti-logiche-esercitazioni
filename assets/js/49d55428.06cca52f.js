"use strict";(self.webpackChunkreti_logiche_esercitazioni=self.webpackChunkreti_logiche_esercitazioni||[]).push([[9846],{17433:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>t});const r=JSON.parse('{"id":"esercitazioni/Assembler/Esercitazioni/Esercitazione 1","title":"Esercitazione 1","description":"","source":"@site/versioned_docs/version-2024-25/esercitazioni/Assembler/Esercitazioni/1. Esercitazione 1.mdx","sourceDirName":"esercitazioni/Assembler/Esercitazioni","slug":"/esercitazioni/Assembler/Esercitazioni/Esercitazione 1","permalink":"/reti-logiche-esercitazioni/2024-25/esercitazioni/Assembler/Esercitazioni/Esercitazione 1","draft":false,"unlisted":false,"tags":[],"version":"2024-25","sidebarPosition":1,"frontMatter":{"description":""},"sidebar":"esercitazioniSidebar","previous":{"title":"Esercitazioni","permalink":"/reti-logiche-esercitazioni/2024-25/category/esercitazioni"},"next":{"title":"Esercitazione 2","permalink":"/reti-logiche-esercitazioni/2024-25/esercitazioni/Assembler/Esercitazioni/Esercitazione 2"}}');var o=n(74848),a=n(28453);const s={description:""},c="Esercitazione 1",l={},t=[{value:"Premesse per programmi nell&#39;ambiente del corso",id:"premesse-per-programmi-nellambiente-del-corso",level:2},{value:"Esercizio 1.1",id:"esercizio-11",level:2},{value:"Uso del debugger",id:"uso-del-debugger",level:2},{value:"Esercizio 1.2: istruzioni stringa",id:"esercizio-12-istruzioni-stringa",level:2},{value:"Esercizi per casa",id:"esercizi-per-casa",level:2},{value:"Esercizi 1.3 e 1.4",id:"esercizi-13-e-14",level:3},{value:"Esercizio 1.5",id:"esercizio-15",level:3},{value:"Esercizio 1.6",id:"esercizio-16",level:3},{value:"Esercizio 1.7",id:"esercizio-17",level:3},{value:"Esercizio 1.8",id:"esercizio-18",level:3}];function d(e){const i={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"esercitazione-1",children:"Esercitazione 1"})}),"\n",(0,o.jsxs)(i.p,{children:["La caratteristica principale del programmare in assembler \xe8 che le operazioni a disposizione sono solo quelle messe a disposizione dal processore.\r\nInfatti, l'assemblatore fa molto poco: dopo aver sostituito le varie label con indirizzi, traduce ciascuna istruzione, nell'ordine in cui sono presenti, nel diretto corrispettivo binario (il cosiddetto linguaggio macchina).\r\nQuesto binario \xe8 poi eseguito direttamente dal processore.\r\nDato un algoritmo per risolvere un problema, i passi base di questo algoritmo ",(0,o.jsx)(i.em,{children:"devono"})," essere istruzioni comprese dal processore, e siamo quindi limitati dall'hardware e le sue caratteristiche."]}),"\n",(0,o.jsxs)(i.p,{children:["Per esempio, dato che il processore non supporta ",(0,o.jsx)(i.code,{children:"mov"})," da un indirizzo di memoria a un'altro indirizzo di memoria, non possiamo fare questa operazione con una sola istruzione: dobbiamo invece scomporre in ",(0,o.jsx)(i.code,{children:"mov src, %eax"})," ",(0,o.jsx)(i.code,{children:"mov %eax, dest"}),", assicurandoci nel frattempo di non aver perso alcun dato importante prima contenuto in ",(0,o.jsx)(i.code,{children:"%eax"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"Per svolgere gli esercizi, bisogna quindi imparare a scomporre strutture di programmazione gi\xe0 note (come if-then-else, cicli, accesso a vettore) nelle operazioni elementari messe ad disposizione dal processore, usando il limitato numero di registri a disposizione al posto di variabili, e tenendo presente quali operazioni da fare con quali dati, senza un sistema di tipizzazione ad aiutarci."}),"\n",(0,o.jsx)(i.h2,{id:"premesse-per-programmi-nellambiente-del-corso",children:"Premesse per programmi nell'ambiente del corso"}),"\n",(0,o.jsxs)(i.p,{children:["Unica eccezione alla logica di cui sopra sono i sottoprogrammi di ingresso/uscita, forniti tramite ",(0,o.jsx)(i.code,{children:"utility.s"}),":\r\nquesti interagiscono con il terminale tramite il ",(0,o.jsx)(i.em,{children:"kernel"})," usando il meccanismo delle ",(0,o.jsx)(i.em,{children:"interruzioni"}),", concetti che avrete il tempo di esplorare in corsi successivi.\r\nQui ci limiteremo a seguirne le specifiche per leggere o stampare a video numeri, caratteri, o stringhe.\r\nPer esempio, parte di queste specifiche \xe8 l'uso del carattere di ritorno carrello ",(0,o.jsx)(i.code,{children:"\\r"})," come terminatore di stringa.\r\nPer usarli, per\xf2, va istruito l'assemblatore di aggiungere questi sottoprogrammi al nostro codice, con"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:'.include "./files/utility.s"\n'})}),"\n",(0,o.jsxs)(i.p,{children:["Un altro aspetto importante \xe8 dove comincia e finisce il nostro programma:\r\n",(0,o.jsx)(i.em,{children:"nell'ambiente del corso"}),", il punto di ingresso \xe8 la label ",(0,o.jsx)(i.code,{children:"_main"})," e quello di uscita \xe8 la corrispendente istruzione ",(0,o.jsx)(i.code,{children:"ret"}),".\r\nPer motivi di debugging, che saranno chiari pi\xf9 avanti, si tende a cominciare il programma con una istruzione ",(0,o.jsx)(i.code,{children:"nop"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Inoltre, la distinzione tra zona ",(0,o.jsx)(i.code,{children:".data"})," e ",(0,o.jsx)(i.code,{children:".text"})," \xe8 importante.\r\nDato che durante l'esecuzione sono ",(0,o.jsx)(i.em,{children:"entrambi"})," caricati in memoria, per motivi di sicurezza il kernel Linux ci impedir\xe0 di ",(0,o.jsx)(i.em,{children:"eseguire"})," indirizzi in ",(0,o.jsx)(i.code,{children:".data"})," o di ",(0,o.jsx)(i.em,{children:"scrivere"})," in indirizzi in ",(0,o.jsx)(i.code,{children:".text"}),".\r\nDimenticarsi di dichiararli porta ad eccezioni durante l'esecuzione."]}),"\n",(0,o.jsx)(i.p,{children:"Infine, l'assemblatore non vede di buon occhio la mancanza di una riga vuota alla fine del file.\r\nPer evitare messaggi di warning inutili, meglio aggiungerla."}),"\n",(0,o.jsxs)(i.p,{children:["Detto ci\xf2, possiamo quindi comprendere il ",(0,o.jsx)(i.a,{href:"pathname:///2024-25/code/assembler/test-ambiente.s",children:"programma di test"}),', che non fa che stampare "Ok." a terminale e poi termina:']}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n.data\r\nmessaggio: .ascii "Ok.\\r"\r\n\r\n.text\r\n_main:  \r\n    nop\r\n    lea messaggio, %ebx\r\n    call outline\r\n    ret\r\n\n'})}),"\n",(0,o.jsxs)(i.admonition,{title:"Non generalit\xe0",type:"note",children:[(0,o.jsxs)(i.p,{children:["Le istruzioni di questa sezione sono relative all'ambiente del corso.\r\nLa direttiva ",(0,o.jsx)(i.code,{children:'.include "./files/utility.s"'})," ricopia il codice del file ",(0,o.jsx)(i.code,{children:"utility.s"}),", fornito nell'ambiente del corso.\r\nLe specifiche dei sottoprogrammi (uso dei registri, ",(0,o.jsx)(i.code,{children:"\\r"})," come carattere di terminazione, etc.) sono conseguenza di come \xe8 scritto questo codice, che ha a che fare con scelte del corso, tra cui la retrocompatibilit\xe0 con il vecchio ambiente DOS.\r\nL'uso di ",(0,o.jsx)(i.code,{children:"_main"})," e ",(0,o.jsx)(i.code,{children:"ret"})," (peraltro, senza alcun valore di ritorno), cos\xec come il comportamento del terminale, sono anche questi relativi all'ambiente usato."]}),(0,o.jsx)(i.p,{children:"Non sono assolutamente concetti validi in generale, per altri assembler e altri ambienti."})]}),"\n",(0,o.jsx)(i.h2,{id:"esercizio-11",children:"Esercizio 1.1"}),"\n",(0,o.jsx)(i.p,{children:"Partiamo da un esercizio con le seguenti specifiche"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"1. Leggere messaggio da terminale.\r\n2. Convertire le lettere minuscole in maiuscolo.\r\n3. Stampare messaggio modificato.\n"})}),"\n",(0,o.jsxs)(i.p,{children:["I passi 1 e 3 sono da svolgersi usando i sottoprogrammi ",(0,o.jsx)(i.code,{children:"inline"})," e ",(0,o.jsx)(i.code,{children:"outline"}),".\r\nCominciamo riservando in memoria, nella sezione data, spazio per le due stringhe."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:".data\r\n\r\nmsg_in: .fill 80, 1, 0\r\nmsg_out: .fill 80, 1, 0\n"})}),"\n",(0,o.jsx)(i.p,{children:"Per la lettura useremo"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"mov $80, %cx\r\nlea msg_in, %ebx\r\ncall inline\n"})}),"\n",(0,o.jsx)(i.p,{children:"Per la scrittura invece useremo"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"lea msg_out, %ebx\r\ncall outline\n"})}),"\n",(0,o.jsx)(i.p,{children:"Quel che manca ora \xe8 il punto 2.\r\nDobbiamo (capire come) fare diverse cose:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["ricopiare ",(0,o.jsx)(i.code,{children:"msg_in"})," in ",(0,o.jsx)(i.code,{children:"msg_out"})," carattere per carattere"]}),"\n",(0,o.jsxs)(i.li,{children:["controllare tale carattere, per capire se \xe8 una lettera minuscola","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"se s\xec, cambiare tale carattere nella corrispondente maiuscola"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Partiamo dal primo di questi punti, e per semplicit\xe0, scriviamone il codice ignorando i restanti due punti, ossia ricopiando il carattere indipendentemente dal fatto che sia minuscolo o maiuscolo."}),"\n",(0,o.jsxs)(i.p,{children:["Come scorrere i due vettori? Abbiamo due opzioni: usare un indice per accesso indicizzato, o due puntatori da incrementare.\r\nAnche sulla condizione di terminazione abbiamo due opzioni: fermarsi dopo aver processato il carattere di ritorno carrello ",(0,o.jsx)(i.code,{children:"\\r"}),", o dopo aver processato 80 caratteri."]}),"\n",(0,o.jsx)(i.p,{children:"Per questo esercizio, scegliamo la prima opzione per entrambe le scelte.\r\nSe usassimo C, scriveremmo questo:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-c",children:"char[] msg_in, msg_out;\r\n...\r\nint i = 0;\r\nchar c;\r\ndo {\r\n    c = msg_in[i];\r\n    msg_out[i] = c;\r\n    i++;\r\n} while (c != '\\r')\n"})}),"\n",(0,o.jsx)(i.p,{children:"In assembler, questo si pu\xf2 scrivere cos\xec:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    mov $0, %ecx\r\nloop:   \r\n    movb (%esi, %ecx), %al\r\n    movb %al, (%edi, %ecx)\r\n    inc %ecx\r\n    cmp $0x0d, %al\r\n    jne loop\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Ci sono diversi aspetti da sottolineare.\r\nIl primo \xe8 che nell'accesso con indice, a differenza del C, abbiamo completo controllo sia di come \xe8 calcolato l'indirizzo di accesso, sia sulla dimensione della lettura in memoria. Prendiamo il caso di ",(0,o.jsx)(i.code,{children:"movb (%esi, %ecx), %al"}),".\r\nRicordiamo che il formato dell'indirizzazione con indice \xe8 ",(0,o.jsx)(i.code,{children:"offset(%base, %indice, scala)"}),", dove l'indirizzo \xe8 calcolato come ",(0,o.jsx)(i.code,{children:"offset + %base + (%indice * scala)"}),".\r\nDunque ",(0,o.jsx)(i.code,{children:"(%esi, %ecx)"})," \xe8, implicitamente, ",(0,o.jsx)(i.code,{children:"0(%esi, %ecx, 1)"}),", dove l'1 indica il fatto che ci spostiamo di un un byte alla volta.\r\nDato l'indirizzo, per\xf2, in abbiamo controllo di quanti byte leggere, questa volta tramite il suffisso ",(0,o.jsx)(i.code,{children:"b"})," o, implicitamente, tramite la dimensione del registro di destinazione ",(0,o.jsx)(i.code,{children:"%al"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["In C, questi aspetti sono legati al fatto di usare il tipo ",(0,o.jsx)(i.code,{children:"char"}),", che \xe8 appunto di 1 byte.\r\nIn assembler, ",(0,o.jsx)("u",{children:"dobbiamo starci attenti noi"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"Prima di passare al resto del punto 2, vale la pena provare a comporre il programma cos\xec com'\xe8, testarlo ed eseguirlo.\r\nInfatti, \xe8 sempre una buona idea trovare i bug quanto prima, e quanto pi\xf9 \xe8 semplice il codice scritto tanto pi\xf9 lo \xe8 trovare la fonte del bug."}),"\n",(0,o.jsxs)(i.p,{children:["Ci rimane ora da controllare che il carattere letto sia una minuscola, e nel caso cambiarla in maiuscola.\r\nPer il primo punto, ci basta ricordare che i caratteri ASCII hanno una codifica binaria ordinata: ",(0,o.jsx)(i.code,{children:"char c"})," \xe8 minuscola se ",(0,o.jsx)(i.code,{children:"c >= 'a' && c <= 'z'"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Per cambiare invece una minuscola e maiuscola, notiamo sempre dalla tabella ASCII che la distanza tra ",(0,o.jsx)(i.code,{children:"'a'"})," e ",(0,o.jsx)(i.code,{children:"'A'"}),", \xe8 la stessa di qualunque altra coppia di maiuscola-minuscola; ci basta infatti sottrarre 32 ad una minuscola per ottenere la corrispondente maiuscola, e aggiungere 32 per fare il contrario.\r\nGuardando alla rappresentazione in base 2, notiamo che l'operazione \xe8 ancora pi\xf9 semplice: essendo ",(0,o.jsxs)(i.span,{className:"katex",children:[(0,o.jsx)(i.span,{className:"katex-mathml",children:(0,o.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(i.semantics,{children:[(0,o.jsxs)(i.mrow,{children:[(0,o.jsx)(i.mn,{children:"32"}),(0,o.jsx)(i.mo,{children:"="}),(0,o.jsxs)(i.msup,{children:[(0,o.jsx)(i.mn,{children:"2"}),(0,o.jsx)(i.mn,{children:"5"})]})]}),(0,o.jsx)(i.annotation,{encoding:"application/x-tex",children:"32 = 2^5"})]})})}),(0,o.jsxs)(i.span,{className:"katex-html","aria-hidden":"true",children:[(0,o.jsxs)(i.span,{className:"base",children:[(0,o.jsx)(i.span,{className:"strut",style:{height:"0.6444em"}}),(0,o.jsx)(i.span,{className:"mord",children:"32"}),(0,o.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,o.jsx)(i.span,{className:"mrel",children:"="}),(0,o.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,o.jsxs)(i.span,{className:"base",children:[(0,o.jsx)(i.span,{className:"strut",style:{height:"0.8141em"}}),(0,o.jsxs)(i.span,{className:"mord",children:[(0,o.jsx)(i.span,{className:"mord",children:"2"}),(0,o.jsx)(i.span,{className:"msupsub",children:(0,o.jsx)(i.span,{className:"vlist-t",children:(0,o.jsx)(i.span,{className:"vlist-r",children:(0,o.jsx)(i.span,{className:"vlist",style:{height:"0.8141em"},children:(0,o.jsxs)(i.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,o.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,o.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,o.jsx)(i.span,{className:"mord mtight",children:"5"})})]})})})})})]})]})]})]}),", si tratta di mettere il bit in posizione 5 a 0 o 1, usando ",(0,o.jsx)(i.code,{children:"and"}),", ",(0,o.jsx)(i.code,{children:"or"})," o ",(0,o.jsx)(i.code,{children:"xor"})," con maschere appropriate."]}),"\n",(0,o.jsx)(i.p,{children:"Detto ci\xf2, il codice C diventa:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-c",children:"char[] msg_in, msg_out;\r\n...\r\nint i = 0;\r\nchar c;\r\ndo {\r\n    c = msg_in[i];\r\n    if(c >= 'a' && c <= 'z')\r\n        c = c & 0xdf;\r\n    msg_out[i] = c;\r\n    i++;\r\n} while (c != '\\r')\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Dove ",(0,o.jsx)(i.code,{children:"0xdf"})," corrisponde a ",(0,o.jsx)(i.code,{children:"1101 1111"}),", ossia l'",(0,o.jsx)(i.code,{children:"and"})," resetta il bit in posizione 5."]}),"\n",(0,o.jsxs)(i.admonition,{title:"Il controllo non \xe8 opzionale",type:"tip",children:[(0,o.jsx)(i.p,{children:"Domanda: se vogliamo che tutte le lettere siano maiuscole, non basta resettare il bit 5 a prescindere, e non fare il controllo?"}),(0,o.jsxs)(i.p,{children:["Risposta: no, perch\xe9 ci sono altri caratteri ASCII con il bit 5 a 1 che non sono affatto lettere. Per esempio, il carattere spazio di codifica ",(0,o.jsx)(i.code,{children:"0x20"}),"."]})]}),"\n",(0,o.jsx)(i.p,{children:"Questo si traduce nel seguente assembler:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    mov $0, %ecx\r\nloop:   \r\n    movb (%esi, %ecx), %al\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n\r\n    and $0xdf, %al      # 1101 1111 -> l'and resetta il bit 5\r\n\r\npost_check:\r\n    movb %al, (%edi, %ecx)\r\n    inc %ecx\r\n    cmp $0x0d, %al\r\n    jne loop\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Notiamo che le due condizione nell'if vanno rimaneggiate per essere tradotte, infatti saltiamo a dopo la conversione se le condizioni ",(0,o.jsx)(i.em,{children:"non"})," sono verificate."]}),"\n",(0,o.jsxs)(i.p,{children:["Il codice finale \xe8 quindi il seguente, scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2024-25/code/assembler/1/maiusc.s",children:"qui"})," come file sorgente."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",metastring:"showLineNumbers",children:".include \"./files/utility.s\"\r\n\r\n.data\r\nmsg_in: .fill 80, 1, 0\r\nmsg_out: .fill 80, 1, 0\r\n\r\n.text\r\n_main:  \r\n    nop\r\npunto_1:\r\n    mov $80, %cx\r\n    lea msg_in, %ebx\r\n    call inline\r\n    nop\r\npunto_2:\r\n    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    mov $0, %ecx\r\nloop:   \r\n    movb (%esi, %ecx), %al\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n    and $0xdf, %al\r\npost_check:\r\n    movb %al, (%edi, %ecx)\r\n    inc %ecx\r\n    cmp $0x0d, %al\r\n    jne loop\r\npunto_3:\r\n    lea msg_out, %ebx\r\n    call outline\r\n    nop\r\nfine:\r\n    ret\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Le label ",(0,o.jsx)(i.code,{children:"punto_1"}),", ",(0,o.jsx)(i.code,{children:"punto_2"}),", ",(0,o.jsx)(i.code,{children:"punto_3"})," e ",(0,o.jsx)(i.code,{children:"fine"})," sono, come \xe8 facile verificare, del tutto opzionali.\r\nSono per\xf2 utili ai fini del debugging, che presentiamo ora."]}),"\n",(0,o.jsxs)(i.p,{children:["Sono da notare le ",(0,o.jsx)(i.code,{children:"nop"})," aggiunte prima tra le ",(0,o.jsx)(i.code,{children:"call"})," alle righe 13 e 33 e le successive label:\r\nqueste sono un workaround per ovviare ad un problema di ",(0,o.jsx)(i.code,{children:"gdb"}),", che spiegher\xf2 pi\xf9 avanti."]}),"\n",(0,o.jsx)(i.h2,{id:"uso-del-debugger",children:"Uso del debugger"}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.em,{children:"Debugging is like being the detective in a crime movie where you are also the murderer."})," ",(0,o.jsx)("br",{}),"\r\n",(0,o.jsx)(i.a,{href:"https://twitter.com/fortes/status/399339918213652480",children:"Filipe Fortes"})]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["La parola ",(0,o.jsx)(i.em,{children:"debugger"})," suggerisce da s\xe9 che sia uno strumento per rimuovere bug ma, purtroppo, questo non vuol dire che lo strumento li rimuove da solo.\r\nInfatti, quello in cui ci \xe8 utile il debugger \xe8 ",(0,o.jsx)(i.em,{children:"trovare"})," i bug, seguendo l'esecuzione del programma passo passo e controllando il suo stato per capire dov'\xe8 che il suo comportamento differisce da quanto ci aspettiamo.\r\nDa l\xec, spesso indagando a ritroso e con un po' di intuito, si pu\xf2 trovare le istruzioni incriminate e correggerle."]}),"\n",(0,o.jsxs)(i.admonition,{title:"Uno strumento per essere pi\xf9 efficienti",type:"tip",children:[(0,o.jsx)(i.p,{children:"Domanda: sembra complicato, non \xe8 pi\xf9 facile rileggere il codice?"}),(0,o.jsxs)(i.p,{children:["Risposta: s\xec, lo \xe8. Ma, in genere, quando basta rileggere \xe8 perch\xe9 si \xe8 fatto un errore di digitazione, non di ragionamento. Saper usare il debugger significa sapersi tirare fuori ",(0,o.jsx)(i.em,{children:"velocemente"})," da errori che richiederebbero rileggere ",(0,o.jsx)(i.em,{children:"a fondo"})," tutto il codice."]})]}),"\n",(0,o.jsxs)(i.p,{children:["Il debugger che usiamo \xe8 ",(0,o.jsx)(i.code,{children:"gdb"}),", che funziona da linea di comando.\r\nQuesto parte da un binario eseguibile, che verr\xe0 eseguito passo passo come da noi indicato."]}),"\n",(0,o.jsxs)(i.p,{children:["Per semplicit\xe0 d'uso, l'ambiente ha uno script ",(0,o.jsx)(i.code,{children:"debug.ps1"}),", da lanciare con"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"./debug.ps1 nome-eseguibile\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Lo script fa dei controlli, tra cui assicurarsi che si sia passato ",(0,o.jsx)(i.em,{children:"l'eseguibile"})," e non ",(0,o.jsx)(i.em,{children:"il sorgente"}),", lancia il debugger con alcuni comandi tipici gi\xe0 inseriti (imposta un breakpoint a ",(0,o.jsx)(i.code,{children:"_main"})," e lancia il programma), e ne definisce altri per comodit\xe0 d'uso (",(0,o.jsx)(i.code,{children:"rr"})," e ",(0,o.jsx)(i.code,{children:"qq"}),", per riavviare il programma o uscire senza dare conferma)."]}),"\n",(0,o.jsx)(i.p,{children:"Vediamo come usarlo, lanciando il debugger sul programma realizzato nell'esercizio precedente.\r\nDopo un sezione di presentazione del programma, abbiamo del testo del tipo"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"Breakpoint 1, _main () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:9\r\n9           nop\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["Un breakpoint \xe8 un punto del programma, in genere una linea di codice, dove si desidera che il debugger fermi l'esecuzione.\r\nAvendo impostato il primo breakpoint a ",(0,o.jsx)(i.code,{children:"_main"}),", vediamo infatti che il programma si ferma alla prima istruzione relativa, che \xe8 appunto la ",(0,o.jsx)(i.code,{children:"nop"}),".\r\nImportante: il debugger si ferma ",(0,o.jsx)(i.em,{children:"prima"})," dell'esecuzione della riga indicata."]}),"\n",(0,o.jsxs)(i.p,{children:["Vediamo poi che il debugger richiede input: infatti possiamo interagire con il debugger ",(0,o.jsx)(i.em,{children:"solo"})," quando il programma \xe8 fermo.\r\nPossiamo fare tre cose in particolare:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Osservare il contenuto di registri e indirizzi di memoria (",(0,o.jsx)(i.code,{children:"info registers"})," e ",(0,o.jsx)(i.code,{children:"x"}),"),"]}),"\n",(0,o.jsxs)(i.li,{children:["Impostare nuovi breakpoints (",(0,o.jsx)(i.code,{children:"break"}),"),"]}),"\n",(0,o.jsxs)(i.li,{children:["Continuare l'esecuzione in modo controllato (",(0,o.jsx)(i.code,{children:"step"})," e ",(0,o.jsx)(i.code,{children:"next"}),") o fino al prossimo breakpoint (",(0,o.jsx)(i.code,{children:"continue"}),")"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Vediamoli in azione. Cominciamo con il proseguire fino alla riga 13."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"Breakpoint 1, _main () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:9\r\n9           nop\r\n(gdb) step\r\npunto_1 () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:11\r\n11          mov $80, %cx\r\n(gdb) s\r\n12          lea msg_in, %ebx\r\n(gdb) s\r\n13          call inline\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["Notiamo che ",(0,o.jsx)(i.code,{children:"gdb"})," accetta sia comandi per esteso sia abbreviati, per esempio per ",(0,o.jsx)(i.code,{children:"step"})," va bene anche ",(0,o.jsx)(i.code,{children:"s"}),".\r\nCon questi 3 step, abbiamo eseguito le prime tre istruzioni ma ",(0,o.jsx)(i.em,{children:"non"})," la ",(0,o.jsx)(i.code,{children:"call"})," a riga 13.\r\nPossiamo controllare lo stato dei registri usando ",(0,o.jsx)(i.code,{children:"info registers"}),", abbreviabile con ",(0,o.jsx)(i.code,{children:"i r"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) i r\r\neax            0x66                102\r\necx            0x50                80\r\nedx            0x2d                45\r\nebx            0x56559066          1448448102\r\nesp            0xffffc06c          0xffffc06c\r\nebp            0xffffc078          0xffffc078\r\nesi            0xf7fb2000          -134537216\r\nedi            0xf7fb2000          -134537216\r\neip            0x5655676e          0x5655676e <punto_1+10>\r\neflags         0x282               [ SF IF ]\r\ncs             0x23                35\r\nss             0x2b                43\r\nds             0x2b                43\r\nes             0x2b                43\r\nfs             0x0                 0\r\ngs             0x63                99\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsxs)(i.p,{children:["Notare: \xe8 ",(0,o.jsx)(i.em,{children:"un caso"})," trovare i registri gi\xe0 inizializzati a 0, come qui mostrato."]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Questo ci da info su diversi registri, molti dei quali non ci interessano.\r\nPossiamo specificare quali registri vogliamo, anche di dimensioni minori di 32 bit."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) i r cx ebx\r\ncx             0x50                80\r\nebx            0x56559066          1448448102\r\n(gdb)\n"})}),"\n",(0,o.jsxs)(i.p,{children:["La prossima istruzione, se lasciamo il programma eseguire, \xe8 una ",(0,o.jsx)(i.code,{children:"call"}),".\r\nIn questo caso, abbiamo due scelte: proseguire ",(0,o.jsx)(i.em,{children:"nella"})," chiamata al sottoprogramma (andando quindi alle istruzioni di ",(0,o.jsx)(i.code,{children:"inline"}),", definite in ",(0,o.jsx)(i.code,{children:"utility.s"}),"), o ",(0,o.jsx)(i.em,{children:"oltre"})," la chiamata, andando quindi direttamente alla riga 14.\r\nQuesta \xe8 la differenza fra ",(0,o.jsx)(i.code,{children:"step"})," e ",(0,o.jsx)(i.code,{children:"next"}),": ",(0,o.jsx)(i.code,{children:"step"})," prosegue dentro i sottoprogrammi, mentre ",(0,o.jsx)(i.code,{children:"next"})," prosegue finch\xe9 il sottoprogramma non ritorna."]}),"\n",(0,o.jsxs)(i.p,{children:["\xc8 qui per\xf2 che \xe8 rilevante la presenza della ",(0,o.jsx)(i.code,{children:"nop"})," aggiunta a riga 14, prima di ",(0,o.jsx)(i.code,{children:"parte_2"}),".\r\n",(0,o.jsx)(i.code,{children:"next"})," infatti continua fino alla prossima istruzione della ",(0,o.jsx)(i.em,{children:"sezione corrente"})," del codice, che \xe8 in questo caso ",(0,o.jsx)(i.code,{children:"punto_1"}),".\r\nSe per\xf2 tale sezione termina subito dopo la call, e non esiste quindi una successiva istruzione nella stessa sezione, allora usando ",(0,o.jsx)(i.code,{children:"next"})," il programma continuer\xe0 fino alla terminazione.\r\nAggiungere la ",(0,o.jsx)(i.code,{children:"nop"})," ovvia al problema essendo una successiva istruzione ancora parte di ",(0,o.jsx)(i.code,{children:"punto_1"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"13          call inline\r\n(gdb) n\r\nquesto e' un test\r\n14          nop\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["Da notare che \"questo e' un test\" \xe8 proprio l'input inserito da tastiera durante l'esecuzione di ",(0,o.jsx)(i.code,{children:"inline"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Eseguire il programma un'istruzione alla volta pu\xf2 risultare molto lento.\r\nPer esempio, quando vogliamo osservare cosa succede ad una particolare iterazione di un loop.\r\nPer questo ci aiutano ",(0,o.jsx)(i.code,{children:"break"})," e ",(0,o.jsx)(i.code,{children:"continue"}),".\r\nNell'esempio che segue, sono usati per raggiungere rapidamente la quarta iterazione."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) b loop\r\nBreakpoint 2 at 0x56556785: file /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s, line 20.\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) i r ecx\r\necx            0x0                 0\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) i r ecx\r\necx            0x1                 1\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, loop () at /mnt/c/reti_logiche/assembler/lezioni/1/maiusc.s:20\r\n20          movb (%esi, %ecx), %al\r\n(gdb) i r ecx\r\necx            0x3                 3\r\n(gdb) \n"})}),"\n",(0,o.jsxs)(i.p,{children:["L'ultima operazione base da vedere \xe8 osservare valori in memoria.\r\nIl comando ",(0,o.jsx)(i.code,{children:"x"})," sta per ",(0,o.jsx)(i.em,{children:"examine memory"})," ma, a differenza degli altri comandi, esiste solo in forma abbreviata.\r\nIl comando ha 4 argomenti:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"N"}),', il numero di "celle" consecutive della memoria da leggere;']}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"F"}),', il formato con cui interpretare il contenuto di tali "celle", per esempio ',(0,o.jsx)(i.code,{children:"d"})," per decimale e ",(0,o.jsx)(i.code,{children:"c"})," per ASCII;"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"U"}),', la dimensione di ciascuna "cella": ',(0,o.jsx)(i.code,{children:"b"})," per 1 byte, ",(0,o.jsx)(i.code,{children:"h"})," per 2 byte, ",(0,o.jsx)(i.code,{children:"w"})," per 4 byte;"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"addr"}),", l'indirizzo in memoria da cui cominciare la lettura."]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Il formato del comando \xe8 ",(0,o.jsx)(i.code,{children:"x/NFU addr"}),".\r\nGli argomenti ",(0,o.jsx)(i.code,{children:"N"}),", ",(0,o.jsx)(i.code,{children:"F"})," e ",(0,o.jsx)(i.code,{children:"U"})," sono, di default, ",(0,o.jsx)(i.em,{children:"gli ultimi utilizzati"}),". Questo \xe8 infatti un comando ",(0,o.jsx)(i.em,{children:"con memoria"}),".\r\nQuando non sono specificati, si dovr\xe0 omettere anche lo ",(0,o.jsx)(i.code,{children:"/"}),".\r\nL'argomento ",(0,o.jsx)(i.code,{children:"addr"})," si pu\xf2 passare come"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["costante esadecimale, per esempio ",(0,o.jsx)(i.code,{children:"x 0x56559066"}),";"]}),"\n",(0,o.jsxs)(i.li,{children:["label preceduta da ",(0,o.jsx)(i.code,{children:"&"}),", per esempio ",(0,o.jsx)(i.code,{children:"x &msg_in"}),";"]}),"\n",(0,o.jsxs)(i.li,{children:["registro preceduto da ",(0,o.jsx)(i.code,{children:"$"}),", per esempio ",(0,o.jsx)(i.code,{children:"x $esi"}),";"]}),"\n",(0,o.jsxs)(i.li,{children:["espressione basata su aritmetica dei puntatori, per esempio ",(0,o.jsx)(i.code,{children:"x (int*)&msg_in+$ecx"}),"."]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"L'ultima opzione \xe8 abbastanza ostica da sfruttare, vedremo come evitarla con una tecnica alternativa."}),"\n",(0,o.jsx)(i.p,{children:"Vediamo degli esempi tornando al debugging del nostro primo programma:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"(gdb) x/20cb &msg_in\r\n0x56559066:     113 'q' 117 'u' 101 'e' 115 's' 116 't' 111 'o' 32 ' '  101 'e'\r\n0x5655906e:     39 '\\'' 32 ' '  117 'u' 110 'n' 32 ' '  116 't' 101 'e' 115 's'\r\n0x56559076:     116 't' 13 '\\r' 10 '\\n' 0 '\\000'\r\n(gdb) x/20cb &msg_out\r\n0x565590b6:     81 'Q'  85 'U'  69 'E'  0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'      0 '\\000'\r\n0x565590be:     0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'     0 '\\000' 0 '\\000'        0 '\\000'\r\n0x565590c6:     0 '\\000'        0 '\\000'        0 '\\000'        0 '\\000'\r\n(gdb) x/20cb $esi\r\n0x56559066:     113 'q' 117 'u' 101 'e' 115 's' 116 't' 111 'o' 32 ' '  101 'e'\r\n0x5655906e:     39 '\\'' 32 ' '  117 'u' 110 'n' 32 ' '  116 't' 101 'e' 115 's'\r\n0x56559076:     116 't' 13 '\\r' 10 '\\n' 0 '\\000'\n"})}),"\n",(0,o.jsxs)(i.p,{children:["In questo programma usiamo un'indirizzazione con indice per leggere e scrivere lettere nei vettori.\r\nInfatti, vediamo che il registro ",(0,o.jsx)(i.code,{children:"esi"})," punta sempre alla prima lettera del vettore, e abbiamo bisogno di usare anche ",(0,o.jsx)(i.code,{children:"ecx"})," per sapere qual'\xe8 la lettera che il programma intende processare in questa iterazione del loop."]}),"\n",(0,o.jsxs)(i.p,{children:["Per usare la sintassi menzionata sopra, dovremmo ricordarci come tradurre ",(0,o.jsx)(i.code,{children:"(%esi, %ecx)"})," in un'espressione di aritmetica dei puntatori.\r\nUna alternativa molto agevole \xe8 invece la scomposizione dell'istruzione ",(0,o.jsx)(i.code,{children:"movb (%esi, %ecx), %al"})," in due: una ",(0,o.jsx)(i.code,{children:"lea"})," e una ",(0,o.jsx)(i.code,{children:"mov"}),".\r\nInfatti, ricordiamo che la ",(0,o.jsx)(i.code,{children:"lea"})," ci permette di calcolare un indirizzo, anche se con composto con indice, e salvarlo in un registro.\r\nPossiamo per esempio scrivere"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"    lea (%esi, %ecx), %ebx\r\n    movb (%ebx), %al\n"})}),"\n",(0,o.jsxs)(i.p,{children:["In questo modo, l'indirizzo della lettera da leggere sar\xe0 contenuto in ",(0,o.jsx)(i.code,{children:"ebx"}),", cosa che possiamo sfruttare nel debugger con il comando ",(0,o.jsx)(i.code,{children:"x/1cb $ebx"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Come ultime indicazioni sul debugger, menzioniamo il comando ",(0,o.jsx)(i.code,{children:"layout regs"}),", che mostra ad ogni passo i registri e il codice da eseguire, e i comandi ",(0,o.jsx)(i.code,{children:"r"}),", per riavviare il programma e ",(0,o.jsx)(i.code,{children:"q"}),", per terminare il debugger.\r\nLe versioni ",(0,o.jsx)(i.code,{children:"qq"})," e ",(0,o.jsx)(i.code,{children:"rr"}),", ",(0,o.jsx)(i.em,{children:"definite ad hoc nell'ambiente di questo corso"}),", fanno lo stesso senza richiedere conferma."]}),"\n",(0,o.jsx)(i.h2,{id:"esercizio-12-istruzioni-stringa",children:"Esercizio 1.2: istruzioni stringa"}),"\n",(0,o.jsxs)(i.p,{children:["L'esercizio precedente compie un'operazione ripetuta su vettori.\r\nLegge da un vettore, una cella alla volta, ne manipola il contenuto, poi lo scrive su un altro vettore.\r\nQuesto genere di operazioni \xe8 adatto per l'uso delle ",(0,o.jsx)(i.em,{children:"istruzioni stringa"}),"."]}),"\n",(0,o.jsxs)(i.admonition,{title:"Provare da s\xe9",type:"tip",children:[(0,o.jsx)(i.p,{children:"Provare a svolgere da s\xe9 l'esercizio, prima di andare oltre."}),(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"1. Leggere messaggio da terminale.\r\n2. Convertire le lettere minuscole in maiuscolo, usando le istruzioni stringa.\r\n3. Stampare messaggio modificato.\n"})})]}),"\n",(0,o.jsx)(i.p,{children:"Le istruzioni stringa sono un esempio di set di istruzioni specializzate, cio\xe8 istruzioni che non sono pensate per impementare algoritmi generici, ma sono invece pensate per fornire supporto hardware efficiente ad uno specifico set di operazioni che alcuni algoritmi necessitano.\r\nInfatti, ci si pu\xf2 aspettare che tra due programmi equivalenti, uno scritto con sole istruzioni generali e l'altro scritto con istruzioni specializzate, il secondo sar\xe0 molto pi\xf9 performante del primo.\r\nAltri esempi comuni sono le istruzioni a supporto di crittografia, encoding e decoding di stream multimediali, e, pi\xf9 recentemente, neural networks."}),"\n",(0,o.jsx)(i.p,{children:"Questi set di istruzioni sono per\xf2 pi\xf9 \"rigidi\" delle istruzioni ad uso generale.\r\nCi impongono infatti dei modi specifici di organizzare dati e codice, perch\xe9 questi devono essere compatibili con il modo in cui l'algoritmo eseguito da un'istruzione \xe8 implementato in hardware."}),"\n",(0,o.jsx)(i.p,{children:"Nell'esercizio precedente abbiamo considerato due modi di scorrere i due array.\r\nNel primo, che \xe8 quello che abbiamo scelto, si carica l'indirizzo di inizio del vettore, e si usa un altro registro come indice, usando l'indirizzazione con indice.\r\nNel secondo, si usa un registro come puntatore alla cella corrente, inizializzato all'indirizzo di inizio del vettore e poi incrementato (della quantit\xe0 giusta) per passare all'elemento successivo.\r\nIn entrambi i casi, siamo liberi di usare i registri che vogliamo, per esempio non abbiamo nessun problema se scriviamo il programma di prima come segue:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"    lea msg_in, %eax\r\n    lea msg_out, %ebx\r\n    mov $0, %edx\r\nloop:   \r\n    movb (%eax, %edx), %cl\r\n    ...\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Infatti, usare ",(0,o.jsx)(i.code,{children:"esi"})," ed ",(0,o.jsx)(i.code,{children:"edi"})," come registri puntatori, ed ",(0,o.jsx)(i.code,{children:"ecx"})," come registro di indice, \xe8 del tutto opzionale."]}),"\n",(0,o.jsxs)(i.p,{children:["Tutto questo cambia quando si vogliono esare istruzioni specializzate come le istruzioni stringa.\r\nQueste ci impongono di usare ",(0,o.jsx)(i.code,{children:"esi"})," come puntatore al vettore sorgente, ",(0,o.jsx)(i.code,{children:"edi"})," come puntatore al vettore destinatario, ",(0,o.jsx)(i.code,{children:"eax"})," come registro dove scrivere o da cui leggere il valore da trasferire, ",(0,o.jsx)(i.code,{children:"ecx"})," come contatore delle ripetizioni da eseguire, etc.\r\nUna volta scelte le istruzioni da usare, dobbiamo quindi assicurarci di seguire quanto imposto dall'istruzione."]}),"\n",(0,o.jsxs)(i.p,{children:["Per questo esercizio siamo interessati alla ",(0,o.jsx)(i.code,{children:"lods"}),", che legge un valore dal vettore e ne sposta il puntatore allo step successivo, e la ",(0,o.jsx)(i.code,{children:"stos"}),", che scrive un valore nel vettore.\r\nPartiamo dal riscrivere il ",(0,o.jsx)(i.code,{children:"punto_2"})," in modo da rendere l'algoritmo compatibile."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"...\r\npunto_2:\r\n    lea msg_in, %esi\r\n    lea msg_out, %edi\r\nloop:\r\n// highlight-start\r\n    movb (%esi), %al\r\n    inc %esi\r\n// highlight-end\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n    and $0xdf, %al\r\npost_check:\r\n// highlight-start\r\n    movb %al, (%edi)\r\n    inc %edi\r\n// highlight-end\r\n    cmp $0x0d, %al\r\n    jne loop\r\n...\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Abbiamo dunque rimosso l'uso di ",(0,o.jsx)(i.code,{children:"ecx"})," come indice, e usiamo ",(0,o.jsx)(i.code,{children:"esi"})," ed ",(0,o.jsx)(i.code,{children:"edi"})," come puntatori.\r\nIl fatto di usare la ",(0,o.jsx)(i.code,{children:"inc"})," \xe8 legato alla dimensione dei dati, cio\xe8 1 byte.\r\nDovremmo invece scrivere ",(0,o.jsx)(i.code,{children:"add $2, %esi"})," o ",(0,o.jsx)(i.code,{children:"add $4, %esi"})," per dati su 2 o 4 byte.\r\nAltra nota \xe8 che ",(0,o.jsx)(i.em,{children:"incrementiamo"})," i puntatori, anzich\xe9 decrementarli, perch\xe9 stiamo eseguendo l'operazione da sinistra verso destra."]}),"\n",(0,o.jsxs)(i.p,{children:["Siamo pronti adesso a sostiture le istruzioni evidenziate con delle istruzioni stringa.\r\nIl sorgente finale \xe8 scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2024-25/code/assembler/1/maiusc-str.s",children:"qui"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:"...\r\npunto_2:\r\n    lea msg_in, %esi\r\n    lea msg_out, %edi\r\n    // highlight-start\r\n    cld\r\n    // highlight-end\r\nloop:\r\n// highlight-start\r\n    lodsb\r\n// highlight-end\r\n    cmp $'a', %al\r\n    jb post_check\r\n    cmp $'z', %al\r\n    ja post_check\r\n    and $0xdf, %al\r\npost_check:\r\n// highlight-start\r\n    stosb\r\n// highlight-end\r\n    cmp $0x0d, %al\r\n    jne loop\r\n...\n"})}),"\n",(0,o.jsxs)(i.p,{children:["L'istruzione ",(0,o.jsx)(i.code,{children:"cld"})," serve a impostare a 0 il flag di direzione, che serve a indicare alle istruzioni stringa se andare da sinistra verso destra o il contrario.\r\nDato che tutti i registri sono impliciti, dobbiamo sempre specificare la dimensione delle istruzioni, in questo caso ",(0,o.jsx)(i.code,{children:"b"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"Come esercizio, pu\xf2 essere interessante osservare con il debugger l'evoluzione dei registri, osservando come si eseguono pi\xf9 operazioni con una sola istruzione."}),"\n",(0,o.jsx)(i.h2,{id:"esercizi-per-casa",children:"Esercizi per casa"}),"\n",(0,o.jsxs)(i.p,{children:["Parte fondamentale delle esercitazioni \xe8 ",(0,o.jsx)(i.em,{children:"fare pratica"}),".\r\nPer questo, vengono lasciati alcuni esercizi per casa."]}),"\n",(0,o.jsx)(i.h3,{id:"esercizi-13-e-14",children:"Esercizi 1.3 e 1.4"}),"\n",(0,o.jsx)(i.p,{children:"Scrivere dei programmi che si comportano come gli esercizi 1.1 e 1.2, tranne che per il fatto di convertire da maiuscolo in minuscolo anzich\xe9 il contrario."}),"\n",(0,o.jsx)(i.h3,{id:"esercizio-15",children:"Esercizio 1.5"}),"\n",(0,o.jsxs)(i.p,{children:["Scrivere un programma che, a partire dalla sezione ",(0,o.jsx)(i.code,{children:".data"})," che segue (e scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2024-25/code/assembler/1/per-casa/conta_num.s",children:"qui"}),"), conta e stampa il numero di occorrenze di ",(0,o.jsx)(i.code,{children:"numero"})," in ",(0,o.jsx)(i.code,{children:"array"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\n'})}),"\n",(0,o.jsx)(i.h3,{id:"esercizio-16",children:"Esercizio 1.6"}),"\n",(0,o.jsxs)(i.p,{children:["Quello che segue (e scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2024-25/code/assembler/1/per-casa/conta_num_debug.s",children:"qui"}),") \xe8 un tentativo di soluzione dell'esercizio precedente.\r\nContiene tuttavia uno o pi\xf9 bug. Trovarli e correggerli."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",metastring:"showLineNumbers",children:'.include "./files/utility.s"\r\n\r\n.data\r\narray:      .word 1, 256, 256, 512, 42, 2048, 1024, 1, 0\r\narray_len:  .long 9\r\nnumero:     .word 1\r\n\r\n.text\r\n\r\n_main:\r\n    nop\r\n    mov $0, %cl\r\n    mov numero, %ax\r\n    mov $0, %esi\r\n\r\ncomp: \r\n    cmp array_len, %esi\r\n    je fine\r\n    cmpw array(%esi), %ax\r\n    jne poi\r\n    inc %cl\r\n\r\npoi:  \r\n    inc %esi\r\n    jmp comp\r\n\r\nfine: \r\n    mov %cl, %al\r\n    call outdecimal_byte\r\n    ret\n'})}),"\n",(0,o.jsx)(i.h3,{id:"esercizio-17",children:"Esercizio 1.7"}),"\n",(0,o.jsx)(i.p,{children:"Scrivere un programma che svolge quanto segue."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{children:"# leggere 2 numeri interi in base 10, calcolarne il prodotto, e stampare il risultato.\r\n\r\n# lettura:\r\n# come primo carattere leggere il segno del numero, cio\xe8 un '+' o un '-'\r\n# segue il modulo del numero, minore di 256\r\n\r\n# stampa:\r\n# stampare prima il segno del numero (+ o -), poi il modulo in cifre decimali\n"})}),"\n",(0,o.jsx)(i.h3,{id:"esercizio-18",children:"Esercizio 1.8"}),"\n",(0,o.jsxs)(i.p,{children:["Quello che segue (e scaricabile ",(0,o.jsx)(i.a,{href:"pathname:///2024-25/code/assembler/1/per-casa/imul_debug.s",children:"qui"}),") \xe8 un tentativo di soluzione dell'esercizio precedente.\r\nContiene tuttavia uno o pi\xf9 bug. Trovarli e correggerli."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-assembler",metastring:"showLineNumbers",children:".include \"./files/utility.s\"\r\n\r\nmess1:  .asciz \"inserire il primo numero intero:\\r\" \r\nmess2:  .asciz \"inserire il secondo numero intero:\\r\"\r\nmess3:  .asciz \"il prodotto dei due numeri e':\\r\"\r\na:      .word 0\r\nb:      .word 0\r\n\r\n_main:      \r\n    nop\r\n    lea mess1, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, a\r\n\r\n    lea mess2, %ebx\r\n    call outline\r\n    call in_intero\r\n    mov %ax, b\r\n\r\n    mov a, %ax\r\n    mov b, %bx\r\n    imul %bx\r\n\r\n    lea mess3, %ebx\r\n    call outline\r\n    call out_intero\r\n    ret\r\n\r\n# legge un intero composto da segno e modulo minore di 256\r\n# ne lascia la rappresentazione in complemento alla radice base 2 in ax\r\nin_intero:\r\n    push %ebx\r\n    mov $0, %bl\r\nin_segno_loop:   \r\n    call inchar\r\n    cmp $'+', %al\r\n    je in_segno_poi\r\n    cmp $'-', %al\r\n    jne in_segno_loop\r\n    mov $1, %bl\r\nin_segno_poi:\r\n    call outchar\r\n    call indecimal_word\r\n    call newline\r\n    cmp $1, %bl\r\n    jne in_intero_fine\r\n    neg %ax\r\nin_intero_fine:\r\n    pop %ebx\r\n    ret\r\n\r\n# legge la rappresentazione di un numero intero in complemento alla radice base 2 in eax\r\n# lo stampa come segno seguito dalle cifre decimali\r\nout_intero:\r\n    push %ebx\r\n    mov %eax, %ebx\r\n    cmp $0, %ebx\r\n    ja out_intero_pos\r\n    jmp out_intero_neg\r\nout_intero_pos:\r\n    mov $'+', %al\r\n    call outchar\r\n    jmp out_intero_poi\r\nout_intero_neg:\r\n    mov $'-', %al\r\n    call outchar\r\n    neg %ebx\r\n    jmp out_intero_poi\r\nout_intero_poi:\r\n    mov %ebx, %eax\r\n    call outdecimal_long\r\n    pop %ebx\r\n    ret\n"})})]})}function m(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>c});var r=n(96540);const o={},a=r.createContext(o);function s(e){const i=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:i},e.children)}}}]);