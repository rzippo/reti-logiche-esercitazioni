"use strict";(self.webpackChunkreti_logiche_esercitazioni=self.webpackChunkreti_logiche_esercitazioni||[]).push([[5173],{7106:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"esercitazioni/Verilog/Esercitazioni/Esercitazione 3","title":"Esercitazione 3","description":"","source":"@site/docs/esercitazioni/Verilog/Esercitazioni/3. Esercitazione 3.mdx","sourceDirName":"esercitazioni/Verilog/Esercitazioni","slug":"/esercitazioni/Verilog/Esercitazioni/Esercitazione 3","permalink":"/reti-logiche-esercitazioni/esercitazioni/Verilog/Esercitazioni/Esercitazione 3","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"description":""},"sidebar":"esercitazioniSidebar","previous":{"title":"Esercitazione 2","permalink":"/reti-logiche-esercitazioni/esercitazioni/Verilog/Esercitazioni/Esercitazione 2"},"next":{"title":"Documentazione","permalink":"/reti-logiche-esercitazioni/category/documentazione-1"}}');var a=i(4848),r=i(8453),l=i(6025);const t={description:""},o="Esercitazione 3",c={},d=[{value:"Reti sincronizzate",id:"reti-sincronizzate",level:2},{value:"Testbench e generatore di clock",id:"testbench-e-generatore-di-clock",level:3},{value:"Primo esempio di rete sincronizzata: il contatore",id:"primo-esempio-di-rete-sincronizzata-il-contatore",level:3},{value:"Mantenere un segnale per N cicli di clock",id:"mantenere-un-segnale-per-n-cicli-di-clock",level:3},{value:"Esercizio: Handshake e reti combinatorie",id:"esercizio-handshake-e-reti-combinatorie",level:3},{value:"Testbench con input e output per reti sincronizzate",id:"testbench-con-input-e-output-per-reti-sincronizzate",level:3},{value:"Blocchi in parallelo: <code>fork ... join</code>",id:"blocchi-in-parallelo-fork--join",level:4},{value:"Timeout di simulazione",id:"timeout-di-simulazione",level:4},{value:"Linee di errore",id:"linee-di-errore",level:4}];function m(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",math:"math",mdxAdmonitionTitle:"mdxAdmonitionTitle",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"esercitazione-3",children:"Esercitazione 3"})}),"\n",(0,a.jsx)(n.h2,{id:"reti-sincronizzate",children:"Reti sincronizzate"}),"\n",(0,a.jsx)(n.p,{children:"Le reti sincronizzate sono reti logiche con uno stato interno, mantenuto usando registri, che si evolvono a instanti discreti dati da un segnale di clock.\r\nIn questa esercitazione vedremo come realizzarle, simularle e studiarle nell'ambiente d'esame."}),"\n",(0,a.jsx)(n.h3,{id:"testbench-e-generatore-di-clock",children:"Testbench e generatore di clock"}),"\n",(0,a.jsx)(n.p,{children:"Per poter simulare una rete sincronizzata dobbiamo innanzitutto avere un generatore di clock.\r\nIl segnale di clock \xe8 segnale oscillante, che dal punto di vista logico appare come in figura."}),"\n",(0,a.jsx)("img",{src:(0,l.Ay)("img/verilog/3/clock.drawio.png"),alt:"",style:{maxWidth:"30rem"}}),"\n",(0,a.jsxs)(n.admonition,{title:"Clock in realt\xe0",type:"info",children:[(0,a.jsxs)(n.p,{children:["In realt\xe0 i generatori di clock sono basati su cristalli di quarzo, un materiale ",(0,a.jsx)(n.em,{children:"piezoelettrico"})," con il quale si possono realizzare circuiti oscillanti.\r\nQuesti circuiti emettono una tensione oscillante come mostrato in figura (da Wikimedia), notare come l'onda sia molto meno squadrata di quanto presentato al livello logico."]}),(0,a.jsx)("img",{src:"https://upload.wikimedia.org/wikipedia/commons/0/0e/Clock_signal.png",style:{maxWidth:"30rem"}})]}),"\n",(0,a.jsxs)(n.p,{children:["Per i nostri usi, ci baster\xe0 descrivere una rete asincrona che cambia il proprio segnale da 0 a 1, e viceversa, ad intervalli regolari.\r\nUna qualunque descrizione realistica, e dunque ",(0,a.jsx)(n.em,{children:"sintetizzabile"}),", dovrebbe avere a che fare con un segnale di reset che indichi a questa rete da che punto cominciare.\r\nDato che per\xf2 vogliamo usare questo generatore in una testbench simulativa, possiamo utilizzare direttamente i concetti relativi, approfittando della keyword ",(0,a.jsx)(n.code,{children:"initial"})," per mantenere il codice ",(0,a.jsx)(n.em,{children:"semplice"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",metastring:"showLineNumbers",children:"// generatore del segnale di clock\r\nmodule clock_generator(\r\n    clock\r\n);\r\n    output clock;\r\n\r\n    parameter HALF_PERIOD = 5;\r\n\r\n    reg CLOCK;\r\n    assign clock = CLOCK;\r\n\r\n    initial CLOCK <= 0;\r\n    always #HALF_PERIOD CLOCK <= ~CLOCK;\r\n\r\nendmodule\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Notiamo che questa rete ",(0,a.jsx)(n.em,{children:"non \xe8 sintetizzabile"}),". Infatti, utilizza la keyword ",(0,a.jsx)(n.code,{children:"initial"}),", che \xe8 priva di senso in hardware, e un ",(0,a.jsx)(n.code,{children:"reg"})," non come registro ma come variabile, come gi\xe0 visto nelle testbench.\r\nQuesto si nota dal fatto che il ",(0,a.jsx)(n.code,{children:"reg"})," non viene aggiornato in risposta ad un altro segnale, come il positive edge del clock, come invece accade per registri."]}),"\n",(0,a.jsx)(n.admonition,{title:"Periodo del clock",type:"tip",children:(0,a.jsxs)(n.p,{children:["Il parametro ",(0,a.jsx)(n.code,{children:"HALF_PERIOD"})," rende il periodo di questo generatore di clock configurabile.\r\nTipicamente all'esame viene utilizzato il valore default di 5, che implica periodi di clock di 10 unit\xe0 di tempo.\r\nQualora questo cambiasse (per esempio, per permettere reti combinatorie con maggior tempo di attraversamento) sar\xe0 segnalato nel testo."]})}),"\n",(0,a.jsx)(n.p,{children:"Come ogni altra rete, questa viene inclusa nella testbench con una instanziazione."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",children:"module testbench();\r\n    wire clock;\r\n    clock_generator clk(\r\n        .clock(clock)\r\n    );\r\n    ...\r\n    mia_rete dut(\r\n        ...\r\n        .clock(clock)\r\n    );\r\n    ...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Oltre al segnale di clock, una rete sincronizzata avr\xe0 bisogno anche del segnale di reset.\r\nQuesto viene aggiunto come un ",(0,a.jsx)(n.code,{children:"reg"})," pilotato all'inizio del blocco ",(0,a.jsx)(n.code,{children:"initial"})," della testbench."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",children:"module testbench();\r\n    ...\r\n    reg reset_;\r\n    ...\r\n    mia_rete dut(\r\n        ...\r\n        .clock(clock), .reset_(reset_)\r\n    );\r\n    ...\r\n    initial begin\r\n        reset_ = 0;\r\n        #(clk.HALF_PERIOD);\r\n        reset_ = 1;\r\n        ...\r\n    end\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Con la sintassi ",(0,a.jsx)(n.code,{children:"#(clk.HALF_PERIOD);"})," si attendono unit\xe0 di tempo proporzionali al periodo di clock configurato. Questo \xe8 utile ad evitare di modificare manualmente tutte le attese in caso di cambio di clock."]}),"\n",(0,a.jsx)(n.h3,{id:"primo-esempio-di-rete-sincronizzata-il-contatore",children:"Primo esempio di rete sincronizzata: il contatore"}),"\n",(0,a.jsxs)(n.p,{children:["Vediamo ora un semplice esempio di rete sincronizzata, un contatore.\r\nQuesta rete ha un registro di 3 bit inizializzato a 0, che viene incrementato ad ogni ciclo di clock, facendo infine wrap-around da 7 a 0.\r\nIl codice \xe8 scaricabile ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(7694).A+"",children:"qui"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module contatore (\r\n    out,\r\n    clock, reset_\r\n);\r\n    output [2:0] out;\r\n    input clock, reset_;\r\n\r\n    reg [2:0] OUT;\r\n    assign out = OUT;\r\n\r\n    always @(reset_ == 0) begin\r\n        OUT <= 0;\r\n    end\r\n\r\n    always @(posedge clock) if (reset_ == 1) #3 begin\r\n        OUT <= OUT + 1;\r\n    end\r\nendmodule\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Vediamo quindi come questo codice modella il comportamento di una vera rete sincronizzata. Il ",(0,a.jsx)(n.code,{children:"reg"})," ",(0,a.jsx)(n.code,{children:"OUT"})," viene collegato direttamente all'uscita ",(0,a.jsx)(n.code,{children:"out"}),", viene inizializzato a 0 solo in corrispondenza del segnale di reset (righe 11-13) e, durante la normale operazione, viene aggiornato con il valore ",(0,a.jsx)(n.code,{children:"OUT + 1"})," in corrispondenza di un ",(0,a.jsx)(n.code,{children:"posedge"})," del clock.\r\nIl ritardo ",(0,a.jsx)(n.code,{children:"#3"})," modella il tempo ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mi,{children:"T"}),(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"p"}),(0,a.jsx)(n.mi,{children:"r"}),(0,a.jsx)(n.mi,{children:"o"}),(0,a.jsx)(n.mi,{children:"p"}),(0,a.jsx)(n.mi,{children:"a"}),(0,a.jsx)(n.mi,{children:"g"}),(0,a.jsx)(n.mi,{children:"a"}),(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mi,{children:"i"}),(0,a.jsx)(n.mi,{children:"o"}),(0,a.jsx)(n.mi,{children:"n"})]})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"T_{propagation}"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.9694em",verticalAlign:"-0.2861em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.3117em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsxs)(n.span,{className:"mord mtight",children:[(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"p"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"ro"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"p"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"a"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.03588em"},children:"g"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"a"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"t"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"i"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"o"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"n"})]})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.2861em"},children:(0,a.jsx)(n.span,{})})})]})})]})]})})]})," del registro."]}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.mdxAdmonitionTitle,{children:["Assegnamento con ",(0,a.jsx)(n.code,{children:"<="})]}),(0,a.jsxs)(n.p,{children:["\xc8 importante, nelle reti sincronizzate, utilizzare ",(0,a.jsx)(n.code,{children:"<="})," per assegnamenti a registri sul fronte positivo del clock.\r\nQuesto perch\xe9 gli statement con ",(0,a.jsx)(n.code,{children:"<="})," sono intesi come eseguiti ",(0,a.jsx)(n.em,{children:"in parallelo"}),", non ",(0,a.jsx)(n.em,{children:"sequenzialmente"}),".\r\nInfatti, i registri non sono variabili e i loro cambiamenti non sono visibili agli altri registri fino al successivo posedge del clock."]})]}),"\n",(0,a.jsxs)(n.p,{children:["Possiamo vedere come si evolve questa rete, simulandola in una testbench con segnale di clock e reset_ (scaricabile ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(8079).A+"",children:"qui"}),"). Per il resto, la testbench non fa altro che attendere diversi cicli di clock, visto che questa rete non ha alcun input e si evolve in autonomia."]}),"\n",(0,a.jsx)(n.p,{children:"Vediamo l'evoluzione della rete usando GTKWave."}),"\n",(0,a.jsx)("img",{src:(0,l.Ay)("/img/verilog/3/contatore-1.png")}),"\n",(0,a.jsxs)(n.p,{children:["Osserviamo, in particolare, il registro ",(0,a.jsx)(n.code,{children:"OUT"})," e il segnale del clock.\r\nNotiamo che a ogni fronte positivo del clock, ",(0,a.jsx)(n.code,{children:"OUT"})," non cambia immediatamente, ma solo dopo 3 unit\xe0\tdi tempo."]}),"\n",(0,a.jsxs)(n.p,{children:["Dalla teoria sui registri, ricordiamo anche che il nuovo valore assunto dal registro deve essergli dato in input da ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mi,{children:"T"}),(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"s"}),(0,a.jsx)(n.mi,{children:"e"}),(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mi,{children:"u"}),(0,a.jsx)(n.mi,{children:"p"})]})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"T_{setup}"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.9694em",verticalAlign:"-0.2861em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.2806em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsxs)(n.span,{className:"mord mtight",children:[(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"se"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"t"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"u"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"p"})]})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.2861em"},children:(0,a.jsx)(n.span,{})})})]})})]})]})})]})," prima del posedge e fino a ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mi,{children:"T"}),(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"h"}),(0,a.jsx)(n.mi,{children:"o"}),(0,a.jsx)(n.mi,{children:"l"}),(0,a.jsx)(n.mi,{children:"d"})]})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"T_{hold}"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.3361em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsxs)(n.span,{className:"mord mtight",children:[(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"h"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"o"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.01968em"},children:"l"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"d"})]})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,a.jsx)(n.span,{})})})]})})]})]})})]})," dopo il posedge.\r\nQuesto per\xf2 non si nota da questa waveform: non c'\xe8 nulla che rappresenta il valore in ingresso al registro prima del posedge.\r\nTorniamo al codice: alla riga 16 usiamo una espressione combinatoria a sinistra dell'assegnamento.\r\nQuesta espressione viene calcolata dal simulatore Verilog al momento dell'assegnamento, cio\xe8 ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"p"}),(0,a.jsx)(n.mi,{children:"o"}),(0,a.jsx)(n.mi,{children:"s"}),(0,a.jsx)(n.mi,{children:"e"}),(0,a.jsx)(n.mi,{children:"d"}),(0,a.jsx)(n.mi,{children:"g"}),(0,a.jsx)(n.mi,{children:"e"})]})]}),(0,a.jsx)(n.mo,{children:"+"}),(0,a.jsx)(n.mn,{children:"3"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t_{posedge} + 3"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.9012em",verticalAlign:"-0.2861em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.3361em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsxs)(n.span,{className:"mord mtight",children:[(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"p"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"ose"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"d"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.03588em"},children:"g"}),(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"e"})]})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.2861em"},children:(0,a.jsx)(n.span,{})})})]})})]}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"+"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"3"})]})]})]}),", e non prima.\r\nCi\xf2 significa che il simulatore non sta simulando n\xe9 il risultato combinatorio in ingresso al registro, n\xe9 il fatto che sia settato e mantenuto per i giusti tempi."]}),"\n",(0,a.jsxs)(n.p,{children:["Possiamo ovviare al primo di questi problemi introducendo un ",(0,a.jsx)(n.code,{children:"wire"}),", che ci rappresenti la rete combinatoria che calcola il successivo valore di ",(0,a.jsx)(n.code,{children:"OUT"})," (scaricabile ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(761).A+"",children:"qui"}),")."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module contatore (\r\n    out,\r\n    clock, reset_\r\n);\r\n    output [2:0] out;\r\n    input clock, reset_;\r\n\r\n    reg [2:0] OUT;\r\n    assign out = OUT;\r\n\r\n//highlight-start\r\n    wire [2:0] next_out;\r\n    assign #2 next_out = OUT + 1;\r\n//highlight-end\r\n\r\n    always @(reset_ == 0) begin\r\n        OUT <= 0;\r\n    end\r\n\r\n    always @(posedge clock) if (reset_ == 1) #3 begin\r\n//highlight-start\r\n        OUT <= next_out;\r\n//highlight-end        \r\n    end\r\nendmodule\n"})}),"\n",(0,a.jsx)(n.p,{children:"Simulando questa nuova rete, otteniamo la seguente waveform."}),"\n",(0,a.jsx)("img",{src:(0,l.Ay)("/img/verilog/3/contatore-2.png")}),"\n",(0,a.jsxs)(n.p,{children:["Vediamo ora chiaramente che la rete combinatoria che produce ",(0,a.jsx)(n.code,{children:"next_out"})," risponde quasi immediatamente, ma il registro ",(0,a.jsx)(n.code,{children:"OUT"})," non registrer\xe0 il suo valore fino al prossimo posdege del clock.\r\nInfatti, il periodo che separa due posedge \xe8 utilizzato proprio per far propagare i nuovi valori dei registri attraverso reti combinatorie, che andranno a produrre i nuovi ingressi dei registri che questi registreranno al prossimo posedge."]}),"\n",(0,a.jsx)(n.p,{children:"Questo modo di propagarsi dei valori tra un ciclo di clock \xe8 l'altro \xe8 fondamentale per capire come funzionano le reti sincronizzate ed essere quindi in grado di scrivere Verilog corrispondente alla macchina a stati che vogliamo realizzare.\r\nAllo stesso modo, riuscire a leggere questa evoluzione dalla waveform \xe8 fondamentale per rendere queste utili al debugging."}),"\n",(0,a.jsx)(n.h3,{id:"mantenere-un-segnale-per-n-cicli-di-clock",children:"Mantenere un segnale per N cicli di clock"}),"\n",(0,a.jsxs)(n.p,{children:["Vediamo ora l'esempio di una rete sincronizzata con uscita ",(0,a.jsx)(n.code,{children:"out"})," a 1 bit, che, ciclicamente, viene tenuta a 1 per N clock e messa a 0 per 1 clock.\r\nIl codice \xe8 scaricabile in due versioni, ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(4434).A+"",children:"qui"})," senza ",(0,a.jsx)(n.code,{children:"wire"})," di debug e ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(4861).A+"",children:"qui"})," con, mentre la testbench \xe8 ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(9938).A+"",children:"qui"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Per semplicit\xe0, discutiamo direttamente la versione che usa ",(0,a.jsx)(n.code,{children:"wire"})," di debug per evidenziare gli ingressi dei registri."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module out_n_clock(\r\n    out,\r\n    clock, reset_\r\n);\r\n    output out;\r\n    input clock, reset_;\r\n\r\n    reg OUT;\r\n    assign out = OUT;\r\n\r\n    localparam N = 3;\r\n    reg [3:0] COUNT;\r\n\r\n    reg STAR;\r\n    localparam S0 = 0, S1 = 1;\r\n\r\n    always @(reset_ == 0) begin\r\n        COUNT <= N;\r\n        OUT <= 0;\r\n        STAR <= S0;\r\n    end\r\n\r\n    wire [3:0] next_count_s0;\r\n    assign #2 next_count_s0 = COUNT - 1;\r\n\r\n    wire next_star_s0;\r\n    assign #2 next_star_s0 = (COUNT == 1) ? S1 : S0;\r\n    \r\n    always @(posedge clock) if (reset_ == 1) #3 begin\r\n        casex (STAR)\r\n            S0: begin\r\n                COUNT <= next_count_s0;\r\n                OUT <= 1;\r\n                STAR <= next_star_s0;\r\n            end\r\n\r\n            S1: begin\r\n                COUNT <= N;\r\n                OUT <= 0;\r\n                STAR <= S0;\r\n            end\r\n        endcase\r\n    end\r\nendmodule\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Questa rete inizializza ",(0,a.jsx)(n.code,{children:"COUNT"})," a ",(0,a.jsx)(n.code,{children:"N"})," e, in S0, lo decrementa continuamente.\r\nAnzich\xe9 saltare da S0 a S1 quando ",(0,a.jsx)(n.code,{children:"COUNT"})," raggiunge 0, lo facciamo invece quando raggiunge 1.\r\nPerch\xe9? Guardiamo la waveform per capirlo meglio."]}),"\n",(0,a.jsx)("img",{src:(0,l.Ay)("img/verilog/3/out_n_clock-2.png"),alt:""}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"15"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 15"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"15"})]})]})]})," corrisponde il primo posedge del clock con ",(0,a.jsx)(n.code,{children:"reset_"})," a 1.\r\nNotiamo che a questo punto ",(0,a.jsx)(n.code,{children:"OUT"})," \xe8 a 0 per via dell'inizializzazione, ma a ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"18"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 18"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"18"})]})]})]})," questo passa a 1, conseguenza della riga 33.\r\nPer ",(0,a.jsx)(n.code,{children:"COUNT"}),", invece, notiamo che \xe8 stato inizializzato a 3, e subito dopo ",(0,a.jsx)(n.code,{children:"next_count_s0"})," ha calcolato 2 come prossimo valore. A ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"18"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 18"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"18"})]})]})]}),", ",(0,a.jsx)(n.code,{children:"COUNT"})," decrementa a 2."]}),"\n",(0,a.jsxs)(n.p,{children:["Passiamo ora al clock successivo, cio\xe8 ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"25"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 25"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"25"})]})]})]}),". ",(0,a.jsx)(n.code,{children:"COUNT"})," vale 2, assume poco dopo valore 1, a ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"28"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 28"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"28"})]})]})]}),".\r\nNotiamo ",(0,a.jsx)(n.code,{children:"next_star_s0"})," a cavallo di questo cambiamento: subito dopo il passaggio di ",(0,a.jsx)(n.code,{children:"COUNT"})," a 1, ",(0,a.jsx)(n.code,{children:"next_star_s0"})," diventa S1.\r\nSiamo per\xf2 a ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"30"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 30"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"30"})]})]})]}),", non ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"25"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 25"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"25"})]})]})]}),": il check sul valore di ",(0,a.jsx)(n.code,{children:"COUNT"})," non cambia fino a ",(0,a.jsx)(n.em,{children:"dopo"})," il posedge del clock, e quindi ",(0,a.jsx)(n.code,{children:"STAR"})," rimane S0 per un altro ciclo.\r\nAl ciclo dopo, a ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsx)(n.mn,{children:"38"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"t = 38"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"="}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"38"})]})]})]}),", vediamo che lo stato passa dunque a S1, ma ",(0,a.jsx)(n.code,{children:"OUT"})," resta 1: infatti solo al clock dopo il cambio di stato avr\xe0 effetto sui registri, compreso ",(0,a.jsx)(n.code,{children:"COUNT"})," che reinizializzato.\r\nGuardando il filo ",(0,a.jsx)(n.code,{children:"OUT"})," in tutto ci\xf2, notiamo che \xe8 rimasto effettivamente a 1 per ",(0,a.jsx)(n.code,{children:"N = 3"})," cicli di clock, come da specifica."]}),"\n",(0,a.jsxs)(n.p,{children:["Ci sono diversi fattori che possiamo cambiare, ottentendo risultati diversi. Se inizializziamo ",(0,a.jsx)(n.code,{children:"COUNT"})," a ",(0,a.jsx)(n.code,{children:"N - 1"}),", seguendo la stessa logica dovremmo contare fino a 0.\r\nSe anticipiamo il cambio di ",(0,a.jsx)(n.code,{children:"OUT"}),", usando ",(0,a.jsx)(n.code,{children:"OUT <= (COUNT == 1) ? 0 : 1"}),", allora si perde il ciclo in pi\xf9 con ",(0,a.jsx)(n.code,{children:"OUT"})," a 1 e dovremmo cambiare il conteggio di conseguenza.\r\nAnche per strutture apparentemente cos\xec semplici, \xe8 quindi possibile combinare tanti approcci diversi al punto tale che \xe8 difficile dedurre a colpo d'occhio la durata del segnale.\r\n\xc8 per questo importante sapere come si evolvono i vari registri, come si propagano i loro cambi di valori, come ricostruire (e leggere) una waveform."]}),"\n",(0,a.jsx)(n.admonition,{title:"Partire da N bassi",type:"tip",children:(0,a.jsxs)(n.p,{children:["Nello ragionare su comportamenti di questo tipo, che sia a mente o su carta, \xe8 una buona idea partire da ",(0,a.jsx)(n.code,{children:"N"})," bassi, come 1 o 2, e calcolare la durata del segnale in termini di ",(0,a.jsx)(n.code,{children:"N"}),".\r\nPer esempio, in questo esercizio abbiamo visto che inizializzando ",(0,a.jsx)(n.code,{children:"COUNT"})," a ",(0,a.jsx)(n.code,{children:"N"})," otteniamo ",(0,a.jsx)(n.code,{children:"OUT"})," a 1 per ",(0,a.jsx)(n.code,{children:"N"})," cicli di clock.\r\nQuesto varr\xe0 che ",(0,a.jsx)(n.code,{children:"N"})," sia 3 o che sia 12, ma ",(0,a.jsx)(n.code,{children:"N = 3"})," \xe8 molto pi\xf9 rapido da verificare, e ",(0,a.jsx)(n.code,{children:"N = 2"})," lo \xe8 ancora di pi\xf9."]})}),"\n",(0,a.jsx)(n.h3,{id:"esercizio-handshake-e-reti-combinatorie",children:"Esercizio: Handshake e reti combinatorie"}),"\n",(0,a.jsxs)(n.p,{children:["Vediamo un esempio di semplice esercizio che segue uno schema tipico all'esame.\r\nIl testo \xe8 scaricabile ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(1557).A+"",children:"qui"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"La testbench \xe8 pi\xf9 complessa di quanto visto finora, nella prossima sezione vedremo le principali caratteristiche utili per debugging.\r\nPer ora, vediamo come si realizza una rete che risponde a queste specifiche."}),"\n",(0,a.jsxs)(n.p,{children:["Il testo ci chiede di eseguire un handshake dav/rfd con il produttore.\r\nQuesto handshake prevede che, tramite il filo ",(0,a.jsx)(n.code,{children:"rfd"}),' ("ready for data") che va dal consumatore al produttore e il filo ',(0,a.jsx)(n.code,{children:"dav_"}),' ("data valid", attivo basso) che va dal produttore al consumatore, questi si coordinino per la corretta trasmissione del dato.\r\nRicordiamo i passi di questo protocollo:']}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A riposo: ",(0,a.jsx)(n.code,{children:"dav_ = 1"}),", ",(0,a.jsx)(n.code,{children:"rfd = 1"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Comincia il produttore: ",(0,a.jsx)(n.code,{children:"dav_ = 0"}),". Questo segnala che il dato \xe8 valido."]}),"\n",(0,a.jsxs)(n.li,{children:["ACK del consumatore: ",(0,a.jsx)(n.code,{children:"rfd = 0"}),". Questo segnala che il dato \xe8 stato letto."]}),"\n",(0,a.jsxs)(n.li,{children:["Reset del produttore: ",(0,a.jsx)(n.code,{children:"dav_ = 1"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Reset del consumatore: ",(0,a.jsx)(n.code,{children:"rfd = 1"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Un ",(0,a.jsx)(n.em,{children:"protocollo"}),", in generale, descrive come due o pi\xf9 attori devono interagire tra loro.\r\nQuando implementiamo un attore di un protocollo, ci sono due punti importanti da ricordare perch\xe9 questo funzioni:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["vanno eseguiti ",(0,a.jsx)(n.em,{children:"tutti"})," gli step che ci competono, ",(0,a.jsx)(n.em,{children:"quando"})," il protocollo ci dice di farlo;"]}),"\n",(0,a.jsxs)(n.li,{children:["quando il protocollo dice che ",(0,a.jsx)(n.em,{children:"qualcun'altro"})," deve segnalare qualcosa, dobbiamo ",(0,a.jsx)(n.em,{children:"attendere"})," che questo accada."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In questo esercizio, implementiamo il consumatore, che deve prelevare un dato dal produttore.\r\nRileggiamo quindi il protocollo di sopra dal punto di vista del consumatore, per capire cos'\xe8 che dobbiamo fare nella nostra rete."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A riposo, e in particolare al reset iniziale: ",(0,a.jsx)(n.code,{children:"rfd = 1"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Attendiamo che il produttore segnali ",(0,a.jsx)(n.code,{children:"dav_ = 0"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Leggiamo il dato."}),"\n",(0,a.jsxs)(n.li,{children:["Comunichiamo l'avvenuta lettura con ",(0,a.jsx)(n.code,{children:"rfd = 0"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Attendiamo che il produttore segnali ",(0,a.jsx)(n.code,{children:"dav_ = 1"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Segnaliamo il reset del protocollo con ",(0,a.jsx)(n.code,{children:"rfd = 1"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Dall'altra parte, una volta ottenuto il dato valido per ",(0,a.jsx)(n.code,{children:"a"})," e ",(0,a.jsx)(n.code,{children:"b"}),", svolgiamo il conto prescritto utilizzando una rete combinatoria e ne emettiamo il risultato tramite l'uscita ",(0,a.jsx)(n.code,{children:"p"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{title:"Ordine delle operazioni",type:"note",children:[(0,a.jsxs)(n.p,{children:["Non c'\xe8 nessuna prescrizione rigida sull'ordine delle operazioni tra gli step del protocollo e l'immissione del dato in uscita.\r\n\xc8 valido sia completare l'handshake fino al suo reset e ",(0,a.jsx)(n.em,{children:"poi"})," trasmettere il dato, sia trasmettere immediatamente il dato e poi chiudere l'handshake."]}),(0,a.jsx)(n.p,{children:"La testbench dovr\xe0 tenere conto di ci\xf2."})]}),"\n",(0,a.jsx)(n.p,{children:"Nello svolgere il calcolo, dobbiamo implementare una semplice rete combinatoria.\r\nL'aspetto pi\xf9 interessante \xe8 come usarla: dobbiamo assicurarci di campionarne l'output solo quando gli input relativi sono validi."}),"\n",(0,a.jsxs)(n.p,{children:["Da questi ragionamenti, deriviamo la seguente descrizione, scaricabile ",(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(9817).A+"",children:"qui"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",metastring:"showLineNumbers",children:"module ABC(\r\n    a, b, p,\r\n    dav_, rfd,\r\n    clock, reset_\r\n);\r\n    input [3:0] a, b;\r\n    output [5:0] p;\r\n\r\n    input dav_;\r\n    output rfd;\r\n\r\n    input clock, reset_;\r\n\r\n    reg [5:0] P;\r\n    assign p = P;\r\n\r\n    reg RFD;\r\n    assign rfd = RFD;\r\n\r\n    reg [3:0] A, B;\r\n\r\n    wire [5:0] out_rc;\r\n    PERIMETRO_RC rc(\r\n        .a(A), .b(B),\r\n        .p(out_rc)\r\n    );\r\n\r\n    reg [2:0] STAR;\r\n    localparam \r\n        S0 = 0, \r\n        S1 = 1,\r\n        S2 = 2, \r\n        S3 = 3;\r\n    \r\n    always @(reset_ == 0) begin\r\n        RFD <= 1;\r\n        P <= 0;\r\n        STAR <= S0;\r\n    end\r\n\r\n    always @(posedge clock) if (reset_ == 1) #3 begin\r\n        casex (STAR)\r\n            S0: begin\r\n                A <= a;\r\n                B <= b;\r\n                STAR <= (dav_ == 0) ? S1 : S0;\r\n            end \r\n\r\n            S1: begin\r\n                P <= out_rc;\r\n                STAR <= S2;           \r\n            end  \r\n\r\n            S2: begin\r\n                RFD <= 0;\r\n                STAR <= (dav_ == 1) ? S3 : S2;\r\n            end\r\n\r\n            S3: begin\r\n                RFD <= 1;\r\n                STAR <= S0;\r\n            end\r\n        endcase\r\n    end\r\nendmodule\r\n\r\nmodule PERIMETRO_RC(\r\n    a, b,\r\n    p\r\n);\r\n    input [3:0] a, b;\r\n    output [5:0] p;\r\n\r\n    wire [4:0] somma;\r\n    add #( .N(4) ) adder(\r\n        .x(a), .y(b), .c_in(1'b0),\r\n        .s(somma[3:0]), .c_out(somma[4])\r\n    );\r\n    assign p = { somma[3:0], 1'b0 };\r\nendmodule\n"})}),"\n",(0,a.jsx)(n.h3,{id:"testbench-con-input-e-output-per-reti-sincronizzate",children:"Testbench con input e output per reti sincronizzate"}),"\n",(0,a.jsx)(n.p,{children:"Ci muoviamo ora verso reti sincronizzate pi\xf9 complesse, che prendono input da altre reti, svolgono conti, ed emettono output."}),"\n",(0,a.jsxs)(n.h4,{id:"blocchi-in-parallelo-fork--join",children:["Blocchi in parallelo: ",(0,a.jsx)(n.code,{children:"fork ... join"})]}),"\n",(0,a.jsx)(n.p,{children:"Per scrivere testbench per reti combinatorie abbiamo sfruttato la loro inerente semplicit\xe0: dato un nuovo ingresso, una rete combinatoria emette l'output corrispondente dopo un certo tempo. Questo output non varier\xe0 nel tempo finch\xe9 manteniamo l'input costante, anzi in ogni caso allo stesso input corrisponde lo stesso output.\r\nQuesto ci permette di scrivere testbench semplici basate sulla struttura 1) assegno gli ingressi, 2) attendo un tempo sufficiente, 3) controllo le uscite."}),"\n",(0,a.jsxs)(n.p,{children:["Questo non \xe8 per\xf2 fattibile con le reti sincronizzate: ad un singolo ingresso possono corrispondere diversi cambi di stato ed uscite diverse, e il tempo necessario al calcolo \xe8 difficilmente prevedibile.\r\nInoltre, se la rete si coordina tramite handshake con altre reti, non si pu\xf2 determinare a priori in quale ordine eseguir\xe0 questi hadnshake.\r\n\xc8 necessario quindi adottare una struttura che permette a ciascun componente con cui la rete testata interagisce di comportarsi come un componente ",(0,a.jsx)(n.em,{children:"indipendente"})," che non \xe8 bloccato dal proseguire degli altri - proprio come hardware vero."]}),"\n",(0,a.jsxs)(n.p,{children:["Questo \xe8 possibile con il costrutto ",(0,a.jsx)(n.code,{children:"fork ... join"}),".\r\nAll'interno di un ",(0,a.jsx)(n.code,{children:"fork ... join"})," possiamo definire diversi blocchi ",(0,a.jsx)(n.code,{children:"begin ... end"})," il cui codice verr\xe0 eseguito indipendentemente e in parallelo.\r\nPossiamo quindi sfruttare questo per rappresentare diversi componenti."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",children:"fork\r\n    begin : Producer_1\r\n        ...\r\n    end\r\n\r\n    begin : Producer_2\r\n        ...\r\n    end\r\n\r\n    begin : Consumer\r\n        ...\r\n    end\r\njoin\n"})}),"\n",(0,a.jsxs)(n.p,{children:["All'interno dei blocchi ",(0,a.jsx)(n.code,{children:"Producer"})," scriveremo codice per fornire dati di input alla rete, all'interno dei blocchi ",(0,a.jsx)(n.code,{children:"Consumer"})," scriveremo codice per ottenere i dati di output della rete e verificare che questi corrispondano a quanto atteso."]}),"\n",(0,a.jsx)(n.h4,{id:"timeout-di-simulazione",children:"Timeout di simulazione"}),"\n",(0,a.jsx)(n.p,{children:"Un tipo di problema che possiamo incontrare nelle reti sincronizzate ma non nelle reti combinatorie \xe8 la situazione in cui un componente resta in attesa di un segnale che in realt\xe0 non verr\xe0 mai emesso.\r\nPer esempio, questo avviene se la rete da noi realizzata non rispetta il protocollo di handshake."}),"\n",(0,a.jsxs)(n.p,{children:["In questi casi, la simulazione pu\xf2 proseguire ",(0,a.jsx)(n.em,{children:"indefinitivamente"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["\xc8 quindi necessario prevedere un meccanismo di timeout che interrompe la simulazione quando questa stia durando molto pi\xf9 di quanto \xe8 ragionevole aspettarsi.\r\nPossiamo realizzare questo utilizzando sempre ",(0,a.jsx)(n.code,{children:"fork ... join"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",children:'//the following structure is used to wait for expected signals, and fail if too much time passes\r\nfork : f\r\n    begin\r\n        #100000;\r\n        $display("Timeout - waiting for signal failed");\r\n        disable f;\r\n    end\r\n    //actual tests start here\r\n    begin \r\n        //reset phase\r\n        ...\r\n\r\n        fork\r\n            begin : Producer_1\r\n                ...\r\n            end\r\n\r\n            begin : Producer_2\r\n                ...\r\n            end\r\n\r\n            begin : Consumer\r\n                ...\r\n            end\r\n        join\r\n    end\r\njoin\r\n\r\n$finish;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Combinando ",(0,a.jsx)(n.code,{children:"disable f"}),", che interrompe ogni esecuzione all'interno del ",(0,a.jsx)(n.code,{children:"fork ... join"})," iniziale, e ",(0,a.jsx)(n.code,{children:"$finish"})," dopo di questo ci assicuriamo che quando il timeout \xe8 raggiunto la simulazione viene terminata.\r\nQuesto ci lascer\xe0 una waveform che potremo analizzare per capire da dove sia scaturito il blocco."]}),"\n",(0,a.jsx)(n.h4,{id:"linee-di-errore",children:"Linee di errore"}),"\n",(0,a.jsxs)(n.p,{children:["Le simulazioni di reti sincronizzate possono essere molto lunghe (in termini di tempo simulativo, non tempo reale) producendo di conseguenza waveform molto lunghe.\r\nAnalizzare queste waveform in cerca di errori pu\xf2 essere molto tedioso.\r\nPer questo, le testbench d'esame includono solitamente delle ",(0,a.jsx)(n.em,{children:"linee di errore"}),", che evidenziano a colpo d'occhio dov'\xe8 che sia avvenuto un problema."]}),"\n",(0,a.jsxs)(n.p,{children:["Queste linee sono realizzate nella testbench con una variabile ",(0,a.jsx)(n.code,{children:"reg error"})," inizializzata a 0 ed un blocco ",(0,a.jsx)(n.code,{children:"always"})," che risponde ad ogni variazione di ",(0,a.jsx)(n.code,{children:"error"})," per rimetterla a 0 dopo una breve attesa.\r\nQuesta attesa breve ma non nulla fa s\xec che basti assegnare 1 ad ",(0,a.jsx)(n.code,{children:"error"})," per ottenere un'impulso sulla linea, facilmente visibile."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",children:"module testbench();\r\n    ...\r\n    initial begin\r\n        ...\r\n    end\r\n\r\n    reg error;\r\n        initial error = 0;\r\n    always @(posedge error) #1\r\n        error = 0;\r\nendmodule\n"})}),"\n",(0,a.jsx)(n.p,{children:"Possiamo quindi scrivere un check dell'output come segue."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-verilog",children:'if(p != t_p) begin\r\n    $display("Expected %d, received %d", t_p, p);\r\n    error = 1;\r\nend\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In GTKWave, guarando alla linea ",(0,a.jsx)(n.code,{children:"error"})," della testbench questi punti saranno facilmente identificabili nella waveform, come dall'esempio seguente."]}),"\n",(0,a.jsx)("img",{src:(0,l.Ay)("img/verilog/3/error-line-perimetro.png")})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},7694:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/contatore-1-53f8b263a0a62dafe3ff6106081956ae.v"},761:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/contatore-2-818ef27d066f5e069e6a4975c3d760dd.v"},8079:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/testbench-5f660be3132dd37e2bf97337250aaeba.v"},4434:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/out_n_clock-1-e66fbe83fe03f4c320e53fc5aa019e24.v"},4861:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/out_n_clock-2-c63335a6ac40e0467034341a8c19f914.v"},9938:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/testbench-ccfd62333949bedd778e412cd622e5b5.v"},9817:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/soluzione-8a02f0738f7d807eab3666ca2b5987e2.v"},1557:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/testo-2f384a50fdd4902863db3fa671a20a5f.zip"},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>t});var s=i(6540);const a={},r=s.createContext(a);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);